(lp1
S'\nabout the tutorial\nc is a general-purpose, procedural, imperative computer programming language\ndeveloped in 1972 by dennis m. ritchie at the bell telephone laboratories to\ndevelop the unix operating system.'
p2
aS'\nc is the most widely used computer language. it keeps fluctuating at number\none scale of popularity along with java programming language, which is also\nequally popular and most widely used among modern software programmers.'
p3
aS'\n\naudience\nthis tutorial is designed for software programmers with a need to understand\nthe c programming language starting from scratch. this tutorial will give you\nenough understanding on c programming language from where you can take\nyourself to higher level of expertise.'
p4
aS'\n\nprerequisites\nbefore proceeding with this tutorial, you should have a basic understanding of\ncomputer programming terminologies. a basic understanding of any of the\nprogramming languages will help you in understanding the c programming\nconcepts and move fast on the learning track.'
p5
aS'\n\ncopyright & disclaimer\n\xef\x83\xa3 copyright 2014 by tutorials point (i) pvt. ltd.'
p6
aS'\nall the content and graphics published in this e-book are the property of\ntutorials point (i) pvt. ltd. the user of this e-book is prohibited to reuse, retain,\ncopy, distribute or republish any contents or a part of contents of this e-book in\nany manner without written consent of the publisher.'
p7
aS'\nwe strive to update the contents of our website and tutorials as timely and as\nprecisely as possible, however, the contents may contain inaccuracies or errors.'
p8
aS'\ntutorials point (i) pvt. ltd. provides no guarantee regarding the accuracy,\ntimeliness or completeness of our website or its contents including this tutorial.'
p9
aS'\nif you discover any errors on our website or in this tutorial, please notify us at\ncontact@tutorialspoint.com\n\ni\n\ntable of contents\nabout the tutorial ..................................................................................................................................... i\naudience .................................................................................................................................................... i\nprerequisites .............................................................................................................................................. i\ncopyright & disclaimer .............................................................................................................................. i\ntable of contents ...................................................................................................................................... ii\n\n1. overview .............................................................................................................................. 1\nfacts about c ............................................................................................................................................ 1\nwhy use c? ............................................................................................................................................... 1\nc programs................................................................................................................................................ 2\n\n2. enviornment setup ............................................................................................................ 3\ntry it option online .................................................................................................................................. 3\nlocal environment setup .......................................................................................................................... 3\ntext editor ................................................................................................................................................ 3\nthe c compiler ......................................................................................................................................... 4\ninstallation on unix/linux ........................................................................................................................ 4\ninstallation on mac os .............................................................................................................................. 5\ninstallation on windows ........................................................................................................................... 5\n\n3. program structure ........................................................................................................... 6\nhello world example ................................................................................................................................ 6\ncompile and execute c program ............................................................................................................... 7\n\n4. basic syntax ......................................................................................................................... 8\ntokens in c................................................................................................................................................ 8\nsemicolons................................................................................................................................................ 8\ncomments ................................................................................................................................................ 8\nidentifiers ................................................................................................................................................. 9\n\nii\n\nkeywords .................................................................................................................................................. 9\nwhitespace in c ...................................................................................................................................... 10\n\n5. data types........................................................................................................................... 11\ninteger types .......................................................................................................................................... 11\nfloating-point types ............................................................................................................................... 13\nthe void type.......................................................................................................................................... 14\n\n6. variables............................................................................................................................. 15\nvariable definition in c ........................................................................................................................... 15\nvariable declaration in c......................................................................................................................... 16\nlvalues and rvalues in c ......................................................................................................................... 18\n\n7. constants and literals ................................................................................................... 19\ninteger literals ........................................................................................................................................ 19\nfloating-point literals ............................................................................................................................. 20\ncharacter constants ................................................................................................................................ 20\nstring literals .......................................................................................................................................... 21\ndefining constants .................................................................................................................................. 22\nthe #define preprocessor ...................................................................................................................... 22\nthe const keyword ................................................................................................................................. 23\n\n8. storage classes................................................................................................................. 24\nthe auto storage class ............................................................................................................................ 24\nthe register storage class ....................................................................................................................... 24\nthe static storage class ........................................................................................................................... 25\nthe extern storage class ......................................................................................................................... 26\n\n9. operators........................................................................................................................... 28\narithmetic operators .............................................................................................................................. 28\nrelational operators ............................................................................................................................... 30\n\niii\n\nlogical operators .................................................................................................................................... 32\nbitwise operators ................................................................................................................................... 34\nassignment operators ............................................................................................................................ 37\nmisc operators \xe2\x86\xa6 sizeof & ternary ......................................................................................................... 40\noperators precedence in c ...................................................................................................................... 41\n\n10. decision making .............................................................................................................. 45\nif statement ............................................................................................................................................ 46\nif\xe2\x80\xa6else statement ................................................................................................................................... 48\nif...else if...else statement ...................................................................................................................... 49\nnested if statements .............................................................................................................................. 51\nswitch statement .................................................................................................................................... 53\nnested switch statements ...................................................................................................................... 55\nthe ? : operator: ..................................................................................................................................... 57\n\n11. loops ................................................................................................................................. 58\nwhile loop .............................................................................................................................................. 59\nfor loop .................................................................................................................................................. 61\ndo\xe2\x80\xa6while loop ....................................................................................................................................... 63\nnested loops .......................................................................................................................................... 65\nloop control statements ........................................................................................................................ 67\nbreak statement ..................................................................................................................................... 68\ncontinue statement ................................................................................................................................ 70\ngoto statement ....................................................................................................................................... 72\nthe infinite loop ..................................................................................................................................... 74\n\n12. functions ......................................................................................................................... 76\ndefining a function ................................................................................................................................. 76\nfunction declarations ............................................................................................................................. 77\n\niv\n\ncalling a function .................................................................................................................................... 78\nfunction arguments................................................................................................................................ 79\ncall by value ........................................................................................................................................... 80\ncall by reference .................................................................................................................................... 81\n\n13. scope rules....................................................................................................................... 84\nlocal variables ........................................................................................................................................ 84\nglobal variables ...................................................................................................................................... 85\nformal parameters ................................................................................................................................. 86\ninitializing local and global variables ..................................................................................................... 87\n\n14. arrays ............................................................................................................................... 89\ndeclaring arrays ...................................................................................................................................... 89\ninitializing arrays .................................................................................................................................... 89\naccessing array elements ....................................................................................................................... 90\narrays in detail ....................................................................................................................................... 91\nmultidimensional arrays ........................................................................................................................ 92\ntwo-dimensional arrays ......................................................................................................................... 92\ninitializing two-dimensional arrays ....................................................................................................... 93\naccessing two-dimensional array elements .......................................................................................... 93\npassing arrays to functions .................................................................................................................... 94\nreturn array from a function ................................................................................................................ 96\npointer to an array ................................................................................................................................. 99\n\n15. pointers .......................................................................................................................... 101\nwhat are pointers? ............................................................................................................................... 101\nhow to use pointers?............................................................................................................................ 102\nnull pointers ...................................................................................................................................... 103\npointers in detail .................................................................................................................................. 104\npointer arithmetic ................................................................................................................................ 104\nincrementing a pointer ......................................................................................................................... 105\n\nv\n\ndecrementing a pointer ....................................................................................................................... 106\npointer comparisons ............................................................................................................................ 107\narray of pointers .................................................................................................................................. 108\npointer to pointer ................................................................................................................................. 111\npassing pointers to functions .............................................................................................................. 112\nreturn pointer from functions ............................................................................................................ 114\n\n16. strings ............................................................................................................................ 117\n17. structures ..................................................................................................................... 120\ndefining a structure .............................................................................................................................. 120\naccessing structure members ............................................................................................................... 121\nstructures as function arguments ........................................................................................................ 122\npointers to structures ........................................................................................................................... 124\nbit fields ............................................................................................................................................... 126\n\n18. unions ............................................................................................................................. 128\ndefining a union ................................................................................................................................... 128\naccessing union members .................................................................................................................... 129\n\n19. bit fields ......................................................................................................................... 132\nbit field declaration .............................................................................................................................. 133\n\n20. typedef ............................................................................................................................ 136\ntypedef vs #define ................................................................................................................................ 137\n\n21. input and output.......................................................................................................... 139\nthe standard files ................................................................................................................................. 139\nthe getchar() and putchar() functions .................................................................................................. 139\nthe gets() and puts() functions ............................................................................................................. 140\nthe scanf() and printf() functions ......................................................................................................... 141\n\n22. file i/o.............................................................................................................................. 143\nvi\n\nopening files ........................................................................................................................................ 143\nclosing a file ......................................................................................................................................... 144\nwriting a file......................................................................................................................................... 144\nreading a file ........................................................................................................................................ 145\nbinary i/o functions ............................................................................................................................. 146\n\n23. preprocessors ............................................................................................................... 147\npreprocessors examples........................................................................................................................ 148\npredefined macros................................................................................................................................ 148\npreprocessor operators ........................................................................................................................ 150\nthe macro continuation (\\) operator .................................................................................................. 150\nthe stringize (#) operator .................................................................................................................... 150\nthe token pasting (##) operator ......................................................................................................... 150\nthe defined() operator ........................................................................................................................ 151\nparameterized macros .......................................................................................................................... 152\n\n24. header files .................................................................................................................... 153\ninclude syntax....................................................................................................................................... 153\ninclude operation ................................................................................................................................. 153\nonce-only headers ............................................................................................................................... 154\ncomputed includes ............................................................................................................................... 155\n\n25. type casting ................................................................................................................... 156\ninteger promotion ................................................................................................................................ 157\nusual arithmetic conversion................................................................................................................. 157\n\n26. error handling ............................................................................................................. 160\nerrno, perror(), and strerror() ............................................................................................................... 160\ndivide by zero errors............................................................................................................................. 161\nprogram exit status............................................................................................................................... 162\n\nvii\n\n27. recursion ....................................................................................................................... 164\nnumber factorial .................................................................................................................................. 164\nfibonacci series .................................................................................................................................... 165\n\n28. variable arguments ..................................................................................................... 167\n29. memory management ................................................................................................. 170\nallocating memory dynamically ........................................................................................................... 170\nresizing and releasing memory ............................................................................................................ 172\n\n30. command line arguments .......................................................................................... 174\n\nviii\n\n1. overview\n\nc programming\n\nc is a general-purpose, high-level language that was originally developed by\ndennis m. ritchie to develop the unix operating system at bell labs. c was\noriginally first implemented on the dec pdp-11 computer in 1972.'
p10
aS'\nin 1978, brian kernighan and dennis ritchie produced the first publicly available\ndescription of c, now known as the k&r standard.'
p11
aS'\nthe unix operating system, the c compiler, and essentially all unix application\nprograms have been written in c. c has now become a widely used professional\nlanguage for various reasons:\n\xef\x82\xb7\n\neasy to learn\n\n\xef\x82\xb7\n\nstructured language\n\n\xef\x82\xb7\n\nit produces efficient programs\n\n\xef\x82\xb7\n\nit can handle low-level activities\n\n\xef\x82\xb7\n\nit can be compiled on a variety of computer platforms\n\nfacts about c\n\xef\x82\xb7\n\nc was invented to write an operating system called unix.'
p12
aS'\n\n\xef\x82\xb7\n\nc is a successor of b language which was introduced around the early\n1970s.'
p13
aS'\n\n\xef\x82\xb7\n\nthe language was formalized in 1988 by the american national standard\ninstitute (ansi).'
p14
aS'\n\n\xef\x82\xb7\n\nthe unix os was totally written in c.'
p15
aS'\n\n\xef\x82\xb7\n\ntoday c is the most widely used and popular system programming\nlanguage.'
p16
aS'\n\n\xef\x82\xb7\n\nmost of the state-of-the-art software have been implemented using c.'
p17
aS"\n\n\xef\x82\xb7\n\ntoday's most popular linux os and rdbms mysql have been written in\nc."
p18
aS'\n\nwhy use c?\nc was initially used for system development work, particularly the programs that\nmake-up the operating system. c was adopted as a system development\nlanguage because it produces code that runs nearly as fast as the code written\nin assembly language. some examples of the use of c might be:\n\xef\x82\xb7\n\noperating systems\n1\n\nc programming\n\xef\x82\xb7\n\nlanguage compilers\n\n\xef\x82\xb7\n\nassemblers\n\n\xef\x82\xb7\n\ntext editors\n\n\xef\x82\xb7\n\nprint spoolers\n\n\xef\x82\xb7\n\nnetwork drivers\n\n\xef\x82\xb7\n\nmodern programs\n\n\xef\x82\xb7\n\ndatabases\n\n\xef\x82\xb7\n\nlanguage interpreters\n\n\xef\x82\xb7\n\nutilities\n\nc programs\na c program can vary from 3 lines to millions of lines and it should be written\ninto one or more text files with extension ".c"; for example, hello.c. you can\nuse "vi", "vim" or any other text editor to write your c program into a file.'
p19
aS'\nthis tutorial assumes that you know how to edit a text file and how to write\nsource code inside a program file.'
p20
aS'\n\n2\n\nc programming\n\n2. enviornment setup\n\ntry it option online\nyou really do not need to set up your own environment to start learning c\nprogramming language. reason is very simple, we already have set up c\nprogramming environment online, so that you can compile and execute all the\navailable examples online at the same time when you are doing your theory\nwork. this gives you confidence in what you are reading and to check the result\nwith different options. feel free to modify any example and execute it online.'
p21
aS'\ntry following example using\nhttp://www.compileonline.com/.'
p22
aS'\n\nour\n\nonline\n\ncompiler option\n\navailable\n\nat\n\n#include <stdio.h>\n\nint main()\n{\n/* my first program in c */\nprintf("hello, world! \\n");\n\nreturn 0;\n}\nfor most of the examples given in this tutorial, you will find the try it option in\nour website code sections at the top right corner that will take you to the online\ncompiler. so just make use of it and enjoy your learning.'
p23
aS'\n\nlocal environment setup\nif you want to set up your environment for c programming language, you need\nthe following two software tools available on your computer, (a) text editor and\n(b) the c compiler.'
p24
aS'\n\ntext editor\nthis will be used to type your program. examples of a few editors include\nwindows notepad, os edit command, brief, epsilon, emacs, and vim or vi.'
p25
aS'\n\n3\n\nc programming\nthe name and version of text editors can vary on different operating systems.'
p26
aS'\nfor example, notepad will be used on windows, and vim or vi can be used on\nwindows as well as on linux or unix.'
p27
aS'\nthe files you create with your editor are called the source files and they contain\nthe program source codes. the source files for c programs are typically named\nwith the extension ".c".'
p28
aS'\nbefore starting your programming, make sure you have one text editor in place\nand you have enough experience to write a computer program, save it in a file,\ncompile it and finally execute it.'
p29
aS'\n\nthe c compiler\nthe source code written in source file is the human readable source for your\nprogram. it needs to be "compiled" into machine language so that your cpu can\nactually execute the program as per the instructions given.'
p30
aS'\nthe compiler compiles the source codes into final executable programs. the\nmost frequently used and free available compiler is the gnu c/c++ compiler,\notherwise you can have compilers either from hp or solaris if you have the\nrespective operating systems.'
p31
aS'\nthe following section explains how to install gnu c/c++ compiler on various os.'
p32
aS'\nm we keep mentioning c/c++ together because gnu gcc compiler works for\nboth c and c++ programming languages.'
p33
aS'\n\ninstallation on unix/linux\nif you are using linux or unix, then check whether gcc is installed on your\nsystem by entering the following command from the command line:\n$ gcc -v\nif you have gnu compiler installed on your machine, then it should print a\nmessage as follows:\nusing built-in specs.'
p34
aS'\ntarget: i386-redhat-linux\nconfigured with: ../configure --prefix=/usr .......'
p35
aS'\nthread model: posix\ngcc version 4.1.2 20080704 (red hat 4.1.2-46)\nif gcc is not installed, then you will have to install it yourself using the detailed\ninstructions available at http://gcc.gnu.org/install/.'
p36
aS'\nthis tutorial has been written based on linux and all the given examples have\nbeen compiled on the cent os flavor of the linux system.'
p37
aS"\n\n4\n\nc programming\n\ninstallation on mac os\nif you use mac os x, the easiest way to obtain gcc is to download the xcode\ndevelopment environment from apple's web site and follow the simple\ninstallation instructions. once you have xcode setup, you will be able to use gnu\ncompiler for c/c++."
p38
aS'\nxcode is currently available at developer.apple.com/technologies/tools/.'
p39
aS'\n\ninstallation on windows\nto install gcc on windows, you need to install mingw. to install mingw, go to\nthe mingw homepage, www.mingw.org, and follow the link to the mingw\ndownload page. download the latest version of the mingw installation program,\nwhich should be named mingw-<version>.exe.'
p40
aS'\nwhile installing mingw, at a minimum, you must install gcc-core, gcc-g++,\nbinutils, and the mingw runtime, but you may wish to install more.'
p41
aS'\nadd the bin subdirectory of your mingw installation to your path environment\nvariable, so that you can specify these tools on the command line by their simple\nnames.'
p42
aS'\nafter the installation is complete, you will be able to run gcc, g++, ar, ranlib,\ndlltool, and several other gnu tools from the windows command line.'
p43
aS'\n\n5\n\nc programming\n\n3. program structure\n\nbefore we study the basic building blocks of the c programming language, let us\nlook at a bare minimum c program structure so that we can take it as a\nreference in the upcoming chapters.'
p44
aS'\n\nhello world example\na c program basically consists of the following parts:\n\xef\x82\xb7\n\npreprocessor commands\n\n\xef\x82\xb7\n\nfunctions\n\n\xef\x82\xb7\n\nvariables\n\n\xef\x82\xb7\n\nstatements & expressions\n\n\xef\x82\xb7\n\ncomments\n\nlet us look at a simple code that would print the words "hello world":\n#include <stdio.h>\n\nint main()\n{\n/* my first program in c */\nprintf("hello, world! \\n");\n\nreturn 0;\n}\n\nlet us take a look at the various parts of the above program:\n1. the first line of the program #include <stdio.h> is a preprocessor\ncommand, which tells a c compiler to include stdio.h file before going to\nactual compilation.'
p45
aS'\n2. the next line int main() is the main function where the program execution\nbegins.'
p46
aS'\n3. the next line /*...*/ will be ignored by the compiler and it has been put to\nadd additional comments in the program. so such lines are called\ncomments in the program.'
p47
aS'\n6\n\nc programming\n4. the next line printf(...) is another function available in c which causes the\nmessage "hello, world!" to be displayed on the screen.'
p48
aS'\n5. the next line return 0; terminates the main() function and returns the\nvalue 0.'
p49
aS'\n\ncompile and execute c program\nlet us see how to save the source code in a file, and how to compile and run it.'
p50
aS'\nfollowing are the simple steps:\n1. open a text editor and add the above-mentioned code.'
p51
aS'\n2. save the file as hello.c\n3. open a command prompt and go to the directory where you have saved\nthe file.'
p52
aS'\n4. type gcc hello.c and press enter to compile your code.'
p53
aS'\n5. if there are no errors in your code, the command prompt will take you to\nthe next line and would generate a.out executable file.'
p54
aS'\n6. now, type a.out to execute your program.'
p55
aS'\n7. you will see the output "hello world" printed on the screen.'
p56
aS'\n$ gcc hello.c\n$ ./a.out\nhello, world!\nmake sure the gcc compiler is in your path and that you are running it in the\ndirectory containing the source file hello.c.'
p57
aS'\n\n7\n\n4. basic syntax\n\nc programming\n\nyou have seen the basic structure of a c program, so it will be easy to\nunderstand other basic building blocks of the c programming language.'
p58
aS'\n\ntokens in c\na c program consists of various tokens and a token is either a keyword, an\nidentifier, a constant, a string literal, or a symbol. for example, the following c\nstatement consists of five tokens:\nprintf("hello, world! \\n");\nthe individual tokens are:\nprintf\n(\n"hello, world! \\n"\n)\n;\n\nsemicolons\nin a c program, the semicolon is a statement terminator. that is, each individual\nstatement must be ended with a semicolon. it indicates the end of one logical\nentity.'
p59
aS'\ngiven below are two different statements:\nprintf("hello, world! \\n");\nreturn 0;\n\ncomments\ncomments are like helping text in your c program and they are ignored by the\ncompiler. they start with /* and terminate with the characters */ as shown\nbelow:\n/* my first program in c */\n\n8\n\nc programming\nyou cannot have comments within comments and they do not occur within a\nstring or character literals.'
p60
aS'\n\nidentifiers\na c identifier is a name used to identify a variable, function, or any other userdefined item. an identifier starts with a letter a to z, a to z, or an underscore \xe2\x80\x98_\xe2\x80\x99\nfollowed by zero or more letters, underscores, and digits (0 to 9).'
p61
aS'\nc does not allow punctuation characters such as @, $, and % within identifiers.'
p62
aS'\nc is a case-sensitive programming language. thus, manpower and manpower\nare two different identifiers in c. here are some examples of acceptable\nidentifiers:\nmohd\n\nzara\n\nabc\n\nmove_name\n\na_123\n\nmyname50\n\n_temp\n\nj\n\na23b9\n\nretval\n\nkeywords\nthe following list shows the reserved words in c. these reserved words may not\nbe used as constants or variables or any other identifier names.'
p63
aS'\nauto\n\nelse\n\nlong\n\nswitch\n\nbreak\n\nenum\n\nregister\n\ntypedef\n\ncase\n\nextern\n\nreturn\n\nunion\n\nchar\n\nfloat\n\nshort\n\nunsigned\n\nconst\n\nfor\n\nsigned\n\nvoid\n\ncontinue\n\ngoto\n\nsizeof\n\nvolatile\n\ndefault\n\nif\n\nstatic\n\nwhile\n\ndo\n\nint\n\nstruct\n\n_packed\n\ndouble\n\n9\n\nc programming\n\nwhitespace in c\na line containing only whitespace, possibly with a comment, is known as a blank\nline, and a c compiler totally ignores it.'
p64
aS'\nwhitespace is the term used in c to describe blanks, tabs, newline characters\nand comments. whitespace separates one part of a statement from another and\nenables the compiler to identify where one element in a statement, such as int,\nends and the next element begins. therefore, in the following statement:\nint age;\nthere must be at least one whitespace character (usually a space) between int\nand age for the compiler to be able to distinguish them. on the other hand, in\nthe following statement:\nfruit = apples + oranges;\n\n// get the total fruit\n\nno whitespace characters are necessary between fruit and =, or between = and\napples, although you are free to include some if you wish to increase readability.'
p65
aS'\n\n10\n\n5. data types\n\nc programming\n\ndata types in c refer to an extensive system used for declaring variables or\nfunctions of different types. the type of a variable determines how much space\nit occupies in storage and how the bit pattern stored is interpreted.'
p66
aS'\nthe types in c can be classified as follows:\ns.n.'
p67
aS'\n\ntypes and description\n\n1\n\nbasic types:\nthey are arithmetic types and are further classified into: (a) integer\ntypes and (b) floating-point types.'
p68
aS'\n\n2\n\nenumerated types:\nthey are again arithmetic types and they are used to define variables\nthat can only assign certain discrete integer values throughout the\nprogram.'
p69
aS'\n\n3\n\nthe type void:\nthe type specifier void indicates that no value is available.'
p70
aS'\n\n4\n\nderived types:\nthey include (a) pointer types, (b) array types, (c) structure types, (d)\nunion types, and (e) function types.'
p71
aS"\n\nthe array types and structure types are referred collectively as the aggregate\ntypes. the type of a function specifies the type of the function's return value. we\nwill see the basic types in the following section, whereas other types will be\ncovered in the upcoming chapters."
p72
aS'\n\ninteger types\nthe following table provides the details of standard integer types with their\nstorage sizes and value ranges:\n\n11\n\nc programming\n\ntype\n\nstorage\nsize\n\nvalue range\n\nchar\n\n1 byte\n\n-128 to 127 or 0 to 255\n\nunsigned\nchar\n\n1 byte\n\n0 to 255\n\nsigned char\n\n1 byte\n\n-128 to 127\n\nint\n\n2 or 4 bytes\n\n-32,768 to 32,767\n2,147,483,647\n\nunsigned int\n\n2 or 4 bytes\n\n0 to 65,535 or 0 to 4,294,967,295\n\nshort\n\n2 bytes\n\n-32,768 to 32,767\n\nunsigned\nshort\n\n2 bytes\n\n0 to 65,535\n\nlong\n\n4 bytes\n\n-2,147,483,648 to 2,147,483,647\n\nunsigned\nlong\n\n4 bytes\n\n0 to 4,294,967,295\n\nor\n\n-2,147,483,648\n\nto\n\nto get the exact size of a type or a variable on a particular platform, you can\nuse the sizeof operator. the expressions sizeof(type) yields the storage size of\nthe object or type in bytes. given below is an example to get the size of int type\non any machine:\n#include <stdio.h>\n#include <limits.h>\n\nint main()\n{\nprintf("storage size for int : %d \\n", sizeof(int));\n12\n\nc programming\n\nreturn 0;\n}\nwhen you compile and execute the above program, it produces the following\nresult on linux:\nstorage size for int : 4\n\nfloating-point types\nthe following table provides the details of standard floating-point types with\nstorage sizes and value ranges and their precision:\ntype\n\nstorage size\n\nvalue range\n\nprecision\n\nfloat\n\n4 byte\n\n1.2e-38 to 3.4e+38\n\n6 decimal places\n\ndouble\n\n8 byte\n\n2.3e-308 to 1.7e+308\n\n15 decimal places\n\nlong double\n\n10 byte\n\n3.4e-4932 to 1.1e+4932\n\n19 decimal places\n\nthe header file float.h defines macros that allow you to use these values and\nother details about the binary representation of real numbers in your programs.'
p73
aS'\nthe following example prints the storage space taken by a float type and its\nrange values:\n#include <stdio.h>\n#include <float.h>\n\nint main()\n{\nprintf("storage size for float : %d \\n", sizeof(float));\nprintf("minimum float positive value: %e\\n", flt_min );\nprintf("maximum float positive value: %e\\n", flt_max );\nprintf("precision value: %d\\n", flt_dig );\n\nreturn 0;\n13\n\nc programming\n\n}\nwhen you compile and execute the above program, it produces the following\nresult on linux:\nstorage size for float : 4\nminimum float positive value: 1.175494e-38\nmaximum float positive value: 3.402823e+38\nprecision value: 6\n\nthe void type\nthe void type specifies that no value is available. it is used in three kinds of\nsituations:\ns.n.'
p74
aS'\n\ntypes and description\n\n1\n\nfunction returns as void\nthere are various functions in c which do not return any value or you\ncan say they return void. a function with no return value has the return\ntype as void. for example, void exit (int status);\n\n2\n\nfunction arguments as void\nthere are various functions in c which do not accept any parameter. a\nfunction with no parameter can accept a void. for example, int\nrand(void);\n\n3\n\npointers to void\na pointer of type void * represents the address of an object, but not its\ntype. for example, a memory allocation function void *malloc(size_t\nsize); returns a pointer to void which can be casted to any data type.'
p75
aS"\n\n14\n\n6. variables\n\nc programming\n\na variable is nothing but a name given to a storage area that our programs can\nmanipulate. each variable in c has a specific type, which determines the size\nand layout of the variable's memory; the range of values that can be stored\nwithin that memory; and the set of operations that can be applied to the\nvariable."
p76
aS'\nthe name of a variable can be composed of letters, digits, and the underscore\ncharacter. it must begin with either a letter or an underscore. upper and\nlowercase letters are distinct because c is case-sensitive. based on the basic\ntypes explained in the previous chapter, there will be the following basic variable\ntypes:\ntype\n\ndescription\n\nchar\n\ntypically a single octet (one byte). this is an integer type.'
p77
aS'\n\nint\n\nthe most natural size of integer for the machine.'
p78
aS'\n\nfloat\n\na single-precision floating point value.'
p79
aS'\n\ndouble\n\na double-precision floating point value.'
p80
aS'\n\nvoid\n\nrepresents the absence of type.'
p81
aS'\n\nc programming language also allows to define various other types of variables,\nwhich we will cover in subsequent chapters like enumeration, pointer, array,\nstructure, union, etc. for this chapter, let us study only basic variable types.'
p82
aS'\n\nvariable definition in c\na variable definition tells the compiler where and how much storage to create for\nthe variable. a variable definition specifies a data type and contains a list of one\nor more variables of that type as follows:\ntype variable_list;\n\n15\n\nc programming\nhere, type must be a valid c data type including char, w_char, int, float, double,\nbool, or any user-defined object; and variable_list may consist of one or more\nidentifier names separated by commas. some valid declarations are shown here:\nint\n\ni, j, k;\n\nchar\n\nc, ch;\n\nfloat\n\nf, salary;\n\ndouble d;\nthe line int i, j, k; declares and defines the variables i, j and k; which instruct\nthe compiler to create variables named i, j, and k of type int.'
p83
aS'\nvariables can be initialized (assigned an initial value) in their declaration. the\ninitializer consists of an equal sign followed by a constant expression as follows:\ntype variable_name = value;\nsome examples are:\nextern int d = 3, f = 5;\n\n// declaration of d and f.'
p84
aS'\n\nint d = 3, f = 5;\n\n// definition and initializing d and f.'
p85
aS'\n\nbyte z = 22;\n\n// definition and initializes z.'
p86
aS"\n\nchar x = 'x';\n\n// the variable x has the value 'x'."
p87
aS'\n\nfor definition without an initializer: variables with static storage duration are\nimplicitly initialized with null (all bytes have the value 0); the initial value of all\nother variables are undefined.'
p88
aS'\n\nvariable declaration in c\na variable declaration provides assurance to the compiler that there exists a\nvariable with the given type and name so that the compiler can proceed for\nfurther compilation without requiring the complete detail about the variable. a\nvariable declaration has its meaning at the time of compilation only, the\ncompiler needs actual variable declaration at the time of linking the program.'
p89
aS'\na variable declaration is useful when you are using multiple files and you define\nyour variable in one of the files which will be available at the time of linking the\nprogram. you will use the keyword extern to declare a variable at any place.'
p90
aS'\nthough you can declare a variable multiple times in your c program, it can be\ndefined only once in a file, a function, or a block of code.'
p91
aS'\n\nexample\ntry the following example, where variables have been declared at the top, but\nthey have been defined and initialized inside the main function:\n\n16\n\nc programming\n\n#include <stdio.h>\n\n// variable declaration:\nextern int a, b;\nextern int c;\nextern float f;\n\nint main ()\n{\n/* variable definition: */\nint a, b;\nint c;\nfloat f;\n\n/* actual initialization */\na = 10;\nb = 20;\n\nc = a + b;\nprintf("value of c : %d \\n", c);\n\nf = 70.0/3.0;\nprintf("value of f : %f \\n", f);\n\nreturn 0;\n}\nwhen the above code is compiled and executed, it produces the following result:\nvalue of c : 30\nvalue of f : 23.333334\nthe same concept applies on function declaration where you provide a function\nname at the time of its declaration and its actual definition can be given\nanywhere else. for example:\n17\n\nc programming\n\n// function declaration\nint func();\n\nint main()\n{\n// function call\nint i = func();\n}\n\n// function definition\nint func()\n{\nreturn 0;\n}\n\nlvalues and rvalues in c\nthere are two kinds of expressions in c:\n\xef\x82\xb7\n\nlvalue : expressions that refer to a memory location are called "lvalue"\nexpressions. an lvalue may appear as either the left-hand or right-hand\nside of an assignment.'
p92
aS'\n\n\xef\x82\xb7\n\nrvalue : the term rvalue refers to a data value that is stored at some\naddress in memory. an rvalue is an expression that cannot have a value\nassigned to it which means an rvalue may appear on the right-hand side\nbut not on the left-hand side of an assignment.'
p93
aS'\n\nvariables are lvalues and so they may appear on the left-hand side of an\nassignment. numeric literals are rvalues and so they may not be assigned and\ncannot appear on the left-hand side. take a look at the following valid and\ninvalid statements:\nint g = 20;\n\n// valid statement\n\n10 = 20;\n\n// invalid statement; would generate compile-time error\n\n18\n\nc programming\n\n7. constants and literals\n\nconstants refer to fixed values that the program may not alter during its\nexecution. these fixed values are also called literals.'
p94
aS'\nconstants can be of any of the basic data types like an integer constant, a\nfloating constant, a character constant, or a string literal. there are enumeration\nconstants as well.'
p95
aS'\nconstants are treated just like regular variables except that their values cannot\nbe modified after their definition.'
p96
aS'\n\ninteger literals\nan integer literal can be a decimal, octal, or hexadecimal constant. a prefix\nspecifies the base or radix: 0x or 0x for hexadecimal, 0 for octal, and nothing for\ndecimal.'
p97
aS'\nan integer literal can also have a suffix that is a combination of u and l, for\nunsigned and long, respectively. the suffix can be uppercase or lowercase and\ncan be in any order.'
p98
aS'\nhere are some examples of integer literals:\n212\n\n/* legal */\n\n215u\n\n/* legal */\n\n0xfeel\n\n/* legal */\n\n078\n\n/* illegal: 8 is not an octal digit */\n\n032uu\n\n/* illegal: cannot repeat a suffix */\n\nfollowing are other examples of various types of integer literals:\n85\n\n/* decimal */\n\n0213\n\n/* octal */\n\n0x4b\n\n/* hexadecimal */\n\n30\n\n/* int */\n\n30u\n\n/* unsigned int */\n\n30l\n\n/* long */\n\n30ul\n\n/* unsigned long */\n\n19\n\nc programming\n\nfloating-point literals\na floating-point literal has an integer part, a decimal point, a fractional part, and\nan exponent part. you can represent floating point literals either in decimal form\nor exponential form.'
p99
aS'\nwhile representing decimal form, you must include the decimal point, the\nexponent, or both; and while representing exponential form, you must include\nthe integer part, the fractional part, or both. the signed exponent is introduced\nby e or e.'
p100
aS"\nhere are some examples of floating-point literals:\n3.14159\n\n/* legal */\n\n314159e-5l\n\n/* legal */\n\n510e\n\n/* illegal: incomplete exponent */\n\n210f\n\n/* illegal: no decimal or exponent */\n\n.e55\n\n/* illegal: missing integer or fraction */\n\ncharacter constants\ncharacter literals are enclosed in single quotes, e.g., 'x' can be stored in a\nsimple variable of char type."
p101
aS"\na character literal can be a plain character (e.g., 'x'), an escape sequence (e.g.,\n'\\t'), or a universal character (e.g., '\\u02c0')."
p102
aS'\nthere are certain characters in c that represent special meaning when preceded\nby a backslash, for example, newline (\\n) or tab (\\t). here, you have a list of\nsuch escape sequence codes:\nescape\nsequence\n\nmeaning\n\n\\\\\n\n\\ character\n\n\\\'\n\n\' character\n\n\\"\n\n" character\n\n\\?\n\n? character\n\n\\a\n\nalert or bell\n20\n\nc programming\n\n\\b\n\nbackspace\n\n\\f\n\nform feed\n\n\\n\n\nnewline\n\n\\r\n\ncarriage return\n\n\\t\n\nhorizontal tab\n\n\\v\n\nvertical tab\n\n\\ooo\n\noctal number of one to three digits\n\n\\xhh . . .'
p103
aS'\n\nhexadecimal number of one or more digits\n\nfollowing is the example to show a few escape sequence characters:\n#include <stdio.h>\n\nint main()\n{\nprintf("hello\\tworld\\n\\n");\n\nreturn 0;\n}\nwhen the above code is compiled and executed, it produces the following result:\nhello\n\nworld\n\nstring literals\nstring literals or constants are enclosed in double quotes "". a string contains\ncharacters that are similar to character literals: plain characters, escape\nsequences, and universal characters.'
p104
aS'\n21\n\nc programming\nyou can break a long line into multiple lines using string literals and separating\nthem using whitespaces.'
p105
aS'\nhere are some examples of string literals. all the three forms are identical\nstrings.'
p106
aS'\n"hello, dear"\n\n"hello, \\\n\ndear"\n\n"hello, " "d" "ear"\n\ndefining constants\nthere are two simple ways in c to define constants:\n\xef\x82\xb7\n\nusing #define preprocessor\n\n\xef\x82\xb7\n\nusing const keyword\n\nthe #define preprocessor\ngiven below is the form to use #define preprocessor to define a constant:\n#define identifier value\nthe following example explains it in detail:\n#include <stdio.h>\n\n#define length 10\n#define width\n\n5\n\n#define newline \'\\n\'\n\nint main()\n{\n\nint area;\n\narea = length * width;\n22\n\nc programming\n\nprintf("value of area : %d", area);\nprintf("%c", newline);\n\nreturn 0;\n}\nwhen the above code is compiled and executed, it produces the following result:\nvalue of area : 50\n\nthe const keyword\nyou can use const prefix to declare constants with a specific type as follows:\nconst type variable = value;\nthe following example explains it in detail:\n#include <stdio.h>\n\nint main()\n{\nconst int\n\nlength = 10;\n\nconst int\n\nwidth\n\n= 5;\n\nconst char newline = \'\\n\';\nint area;\n\narea = length * width;\nprintf("value of area : %d", area);\nprintf("%c", newline);\n\nreturn 0;\n}\nwhen the above code is compiled and executed, it produces the following result:\nvalue of area : 50\nnote that it is a good programming practice to define constants in capitals.'
p107
aS'\n\n23\n\nc programming\n\n8. storage classes\n\na storage class defines the scope (visibility) and life-time of variables and/or\nfunctions within a c program. they precede the type that they modify. we have\nfour different storage classes in a c program:\n\xef\x82\xb7\n\nauto\n\n\xef\x82\xb7\n\nregister\n\n\xef\x82\xb7\n\nstatic\n\n\xef\x82\xb7\n\nextern\n\nthe auto storage class\nthe auto storage class is the default storage class for all local variables.'
p108
aS'\n{\nint mount;\nauto int month;\n}\nthe example above defines two variables within the same storage class. \xe2\x80\x98auto\xe2\x80\x99\ncan only be used within functions, i.e., local variables.'
p109
aS"\n\nthe register storage class\nthe register storage class is used to define local variables that should be stored\nin a register instead of ram. this means that the variable has a maximum size\nequal to the register size (usually one word) and can't have the unary '&'\noperator applied to it (as it does not have a memory location)."
p110
aS"\n{\nregister int\n\nmiles;\n\n}\nthe register should only be used for variables that require quick access such as\ncounters. it should also be noted that defining 'register' does not mean that the\nvariable will be stored in a register. it means that it might be stored in a\nregister depending on hardware and implementation restrictions."
p111
aS'\n\n24\n\nc programming\n\nthe static storage class\nthe static storage class instructs the compiler to keep a local variable in\nexistence during the life-time of the program instead of creating and destroying\nit each time it comes into and goes out of scope. therefore, making local\nvariables static allows them to maintain their values between function calls.'
p112
aS"\nthe static modifier may also be applied to global variables. when this is done, it\ncauses that variable's scope to be restricted to the file in which it is declared."
p113
aS'\nin c programming, when static is used on a class data member, it causes only\none copy of that member to be shared by all the objects of its class.'
p114
aS'\n#include <stdio.h>\n\n/* function declaration */\nvoid func(void);\n\nstatic int count = 5;\n\n/* global variable */\n\nmain()\n{\nwhile(count--)\n{\nfunc();\n}\nreturn 0;\n}\n/* function definition */\nvoid func( void )\n{\nstatic int i = 5;\n\n/* local static variable */\n\ni++;\nprintf("i is %d and count is %d\\n", i, count);\n}\nwhen the above code is compiled and executed, it produces the following result:\ni is 6 and count is 4\ni is 7 and count is 3\n25\n\nc programming\n\ni is 8 and count is 2\ni is 9 and count is 1\ni is 10 and count is 0\n\nthe extern storage class\nthe extern storage class is used to give a reference of a global variable that is\nvisible to all the program files. when you use \'extern\', the variable cannot be\ninitialized, however, it points the variable name at a storage location that has\nbeen previously defined.'
p115
aS'\nwhen you have multiple files and you define a global variable or function, which\nwill also be used in other files, then extern will be used in another file to provide\nthe reference of defined variable or function. just for understanding, extern is\nused to declare a global variable or function in another file.'
p116
aS'\nthe extern modifier is most commonly used when there are two or more files\nsharing the same global variables or functions as explained below.'
p117
aS'\n\nfirst file: main.c\n#include <stdio.h>\n\nint count;\nextern void write_extern();\n\nmain()\n{\ncount = 5;\nwrite_extern();\n}\n\nsecond file: support.c\n#include <stdio.h>\n\nextern int count;\n\nvoid write_extern(void)\n{\n26\n\nc programming\n\nprintf("count is %d\\n", count);\n}\nhere, extern is being used to declare count in the second file, whereas it has its\ndefinition in the first file, main.c. now, compile these two files as follows:\n$gcc main.c support.c\nit will produce the executable program a.out. when this program is executed, it\nproduces the following result:\n5\n\n27\n\n9. operators\n\nc programming\n\nan operator is a symbol that tells the compiler to perform specific mathematical\nor logical functions. c language is rich in built-in operators and provides the\nfollowing types of operators:\n\xef\x82\xb7\n\narithmetic operators\n\n\xef\x82\xb7\n\nrelational operators\n\n\xef\x82\xb7\n\nlogical operators\n\n\xef\x82\xb7\n\nbitwise operators\n\n\xef\x82\xb7\n\nassignment operators\n\n\xef\x82\xb7\n\nmisc operators\n\nwe will, in this chapter, look into the way each operator works.'
p118
aS'\n\narithmetic operators\nthe following table shows all the arithmetic operators supported by the c\nlanguage. assume variable a holds 10 and variable b holds 20, then:\noperator\n\ndescription\n\nexample\n\n+\n\nadds two operands.'
p119
aS'\n\na + b = 30\n\n-\n\nsubtracts second operand from the first.'
p120
aS'\n\na - b = -10\n\n*\n\nmultiplies both operands.'
p121
aS'\n\na * b = 200\n\n/\n\ndivides numerator by de-numerator.'
p122
aS'\n\nb/a=2\n\n%\n\nmodulus operator and remainder of after an\ninteger division.'
p123
aS'\n\nb%a=0\n\n++\n\nincrement operator increases the integer value\nby one.'
p124
aS'\n\na++ = 11\n\n28\n\nc programming\n\n--\n\ndecrement operator\nvalue by one.'
p125
aS'\n\ndecreases\n\nthe\n\ninteger\n\na-- = 9\n\nexample\ntry the following example to understand all the arithmetic operators available in\nc:\n#include <stdio.h>\n\nmain()\n{\nint a = 21;\nint b = 10;\nint c ;\n\nc = a + b;\nprintf("line 1 - value of c is %d\\n", c );\nc = a - b;\nprintf("line 2 - value of c is %d\\n", c );\nc = a * b;\nprintf("line 3 - value of c is %d\\n", c );\nc = a / b;\nprintf("line 4 - value of c is %d\\n", c );\nc = a % b;\nprintf("line 5 - value of c is %d\\n", c );\nc = a++;\nprintf("line 6 - value of c is %d\\n", c );\nc = a--;\nprintf("line 7 - value of c is %d\\n", c );\n\n}\nwhen you compile and execute the above program, it produces the following\nresult:\nline 1 - value of c is 31\n29\n\nc programming\n\nline 2 - value of c is 11\nline 3 - value of c is 210\nline 4 - value of c is 2\nline 5 - value of c is 1\nline 6 - value of c is 21\nline 7 - value of c is 22\n\nrelational operators\nthe following table shows all the relational operators supported by c. assume\nvariable a holds 10 and variable b holds 20, then:\noperator\n\ndescription\n\nexample\n\n==\n\nchecks if the values of two operands are equal\nor not. if yes, then the condition becomes\ntrue.'
p126
aS'\n\n(a == b) is not\ntrue.'
p127
aS'\n\n!=\n\nchecks if the values of two operands are equal\nor not. if the values are not equal, then the\ncondition becomes true.'
p128
aS'\n\n(a != b) is true.'
p129
aS'\n\n>\n\nchecks if the value of left operand is greater\nthan the value of right operand. if yes, then\nthe condition becomes true.'
p130
aS'\n\n(a > b) is not\ntrue.'
p131
aS'\n\n<\n\nchecks if the value of left operand is less than\nthe value of right operand. if yes, then the\ncondition becomes true.'
p132
aS'\n\n(a < b) is true.'
p133
aS'\n\n>=\n\nchecks if the value of left operand is greater\nthan or equal to the value of right operand. if\nyes, then the condition becomes true.'
p134
aS'\n\n(a >= b) is not\ntrue.'
p135
aS'\n\n<=\n\nchecks if the value of left operand is less than\nor equal to the value of right operand. if yes,\nthen the condition becomes true.'
p136
aS'\n\n(a <= b) is true.'
p137
aS'\n\n30\n\nc programming\n\nexample\ntry the following example to understand all the relational operators available in\nc:\n\n#include <stdio.h>\n\nmain()\n{\nint a = 21;\nint b = 10;\nint c ;\n\nif( a == b )\n{\nprintf("line 1 - a is equal to b\\n" );\n}\nelse\n{\nprintf("line 1 - a is not equal to b\\n" );\n}\nif ( a < b )\n{\nprintf("line 2 - a is less than b\\n" );\n}\nelse\n{\nprintf("line 2 - a is not less than b\\n" );\n}\nif ( a > b )\n{\nprintf("line 3 - a is greater than b\\n" );\n}\nelse\n31\n\nc programming\n\n{\nprintf("line 3 - a is not greater than b\\n" );\n}\n/* lets change value of a and b */\na = 5;\nb = 20;\nif ( a <= b )\n{\nprintf("line 4 - a is either less than or equal to\n\nb\\n" );\n\n}\nif ( b >= a )\n{\nprintf("line 5 - b is either greater than\n\nor equal to b\\n" );\n\n}\n}\nwhen you compile and execute the above program, it produces the following\nresult:\nline 1 - a is not equal to b\nline 2 - a is not less than b\nline 3 - a is greater than b\nline 4 - a is either less than or equal to\nline 5 - b is either greater than\n\nb\n\nor equal to b\n\nlogical operators\nfollowing table shows all the logical operators supported by c language. assume\nvariable a holds 1 and variable b holds 0, then:\noperator\n\ndescription\n\nexample\n\n&&\n\ncalled logical and operator. if both the\noperands are non-zero, then the condition\nbecomes true.'
p138
aS'\n\n(a &&\nfalse.'
p139
aS'\n\n||\n\ncalled logical or operator. if any of the two\n\n(a || b) is true.'
p140
aS'\n\nb)\n\nis\n\n32\n\nc programming\n\noperands is non-zero,\nbecomes true.'
p141
aS'\n!\n\nthen\n\nthe\n\ncondition\n\ncalled logical not operator. it is used to\nreverse the logical state of its operand. if a\ncondition is true, then logical not operator will\nmake it false.'
p142
aS'\n\n!(a &&\ntrue.'
p143
aS'\n\nb)\n\nis\n\nexample\ntry the following example to understand all the logical operators available in c:\n#include <stdio.h>\n\nmain()\n{\nint a = 5;\nint b = 20;\nint c ;\n\nif ( a && b )\n{\nprintf("line 1 - condition is true\\n" );\n}\nif ( a || b )\n{\nprintf("line 2 - condition is true\\n" );\n}\n/* lets change the value of\n\na and b */\n\na = 0;\nb = 10;\nif ( a && b )\n{\nprintf("line 3 - condition is true\\n" );\n}\n33\n\nc programming\n\nelse\n{\nprintf("line 3 - condition is not true\\n" );\n}\nif ( !(a && b) )\n{\nprintf("line 4 - condition is true\\n" );\n}\n}\nwhen you compile and execute the above program, it produces the following\nresult:\nline 1 - condition is true\nline 2 - condition is true\nline 3 - condition is not true\nline 4 - condition is true\n\nbitwise operators\nbitwise operators work on bits and perform bit-by-bit operation. the truth table\nfor &, |, and ^ is as follows:\np\n\nq\n\np&q\n\np|q\n\np^q\n\n0\n\n0\n\n0\n\n0\n\n0\n\n0\n\n1\n\n0\n\n1\n\n1\n\n1\n\n1\n\n1\n\n1\n\n0\n\n1\n\n0\n\n0\n\n1\n\n1\n\nassume a = 60 and b = 13; in binary format, they will be as follows:\na = 0011 1100\nb = 0000 1101\n34\n\nc programming\n----------------a&b = 0000 1100\na|b = 0011 1101\na^b = 0011 0001\n~a = 1100 0011\nthe following table lists the bitwise operators supported by c. assume variable\n\xe2\x80\x98a\xe2\x80\x99 holds 60 and variable \xe2\x80\x98b\xe2\x80\x99 holds 13, then:\noperator\n\ndescription\n\nexample\n\n&\n\nbinary and operator copies a bit to the result\nif it exists in both operands.'
p144
aS'\n\n(a & b) = 12, i.e.,\n0000 1100\n\n|\n\nbinary or operator copies a bit if it exists in\neither operand.'
p145
aS'\n\n(a | b) = 61, i.e.,\n0011 1101\n\n^\n\nbinary xor operator copies the bit if it is set\nin one operand but not both.'
p146
aS"\n\n(a ^ b) = 49, i.e.,\n0011 0001\n\n~\n\nbinary ones complement operator is unary\nand has the effect of 'flipping' bits."
p147
aS"\n\n(~a ) = -61, i.e.,\n1100 0011 in 2's\ncomplement form."
p148
aS'\n\n<<\n\nbinary left shift operator. the left operands\nvalue is moved left by the number of bits\nspecified by the right operand.'
p149
aS'\n\na << 2 = 240,\ni.e., 1111 0000\n\n>>\n\nbinary right shift operator. the left operands\nvalue is moved right by the number of bits\nspecified by the right operand.'
p150
aS'\n\na >> 2 = 15, i.e.,\n0000 1111\n\nexample\ntry the following example to understand all the bitwise operators available in c:\n#include <stdio.h>\n\nmain()\n35\n\nc programming\n\n{\n\nunsigned int a = 60;\n\n/* 60 = 0011 1100 */\n\nunsigned int b = 13;\n\n/* 13 = 0000 1101 */\n\nint c = 0;\n\nc = a & b;\n\n/* 12 = 0000 1100 */\n\nprintf("line 1 - value of c is %d\\n", c );\n\nc = a | b;\n\n/* 61 = 0011 1101 */\n\nprintf("line 2 - value of c is %d\\n", c );\n\nc = a ^ b;\n\n/* 49 = 0011 0001 */\n\nprintf("line 3 - value of c is %d\\n", c );\n\nc = ~a;\n\n/*-61 = 1100 0011 */\n\nprintf("line 4 - value of c is %d\\n", c );\n\nc = a << 2;\n\n/* 240 = 1111 0000 */\n\nprintf("line 5 - value of c is %d\\n", c );\n\nc = a >> 2;\n\n/* 15 = 0000 1111 */\n\nprintf("line 6 - value of c is %d\\n", c );\n}\nwhen you compile and execute the above program, it produces the following\nresult:\nline 1 - value of c is 12\nline 2 - value of c is 61\nline 3 - value of c is 49\nline 4 - value of c is -61\nline 5 - value of c is 240\nline 6 - value of c is 15\n\n36\n\nc programming\n\nassignment operators\nthe following tables lists the assignment operators supported by the c language:\noperator\n\ndescription\n\nexample\n\n=\n\nsimple assignment operator. assigns\nvalues from right side operands to left\nside operand.'
p151
aS'\n\nc = a + b will assign\nthe value of a + b to\nc\n\n+=\n\nadd and assignment operator. it adds the\nright operand to the left operand and\nassigns the result to the left operand.'
p152
aS'\n\nc += a is equivalent\nto c = c + a\n\n-=\n\nsubtract and assignment operator. it\nsubtracts the right operand from the left\noperand and assigns the result to the left\noperand.'
p153
aS'\n\nc -= a is equivalent\nto c = c - a\n\n*=\n\nmultiply and assignment operator. it\nmultiplies the right operand with the left\noperand and assigns the result to the left\noperand.'
p154
aS'\n\nc *= a is equivalent\nto c = c * a\n\n/=\n\ndivide and assignment operator. it\ndivides the left operand with the right\noperand and assigns the result to the left\noperand.'
p155
aS'\n\nc /= a is equivalent\nto c = c / a\n\n%=\n\nmodulus and assignment operator. it\ntakes modulus using two operands and\nassigns the result to the left operand.'
p156
aS'\n\nc %= a is equivalent\nto c = c % a\n\n<<=\n\nleft shift and assignment operator.'
p157
aS'\n\nc <<= 2 is same as c\n= c << 2\n\n>>=\n\nright shift and assignment operator.'
p158
aS'\n\nc >>= 2 is same as c\n= c >> 2\n\n&=\n\nbitwise and assignment operator.'
p159
aS'\n\nc &= 2 is same as c\n37\n\nc programming\n\n=c&2\n^=\n\nbitwise exclusive\noperator.'
p160
aS'\n\nor\n\nand\n\nassignment\n\nc ^= 2 is same as c\n=c^2\n\n|=\n\nbitwise inclusive\noperator.'
p161
aS'\n\nor\n\nand\n\nassignment\n\nc |= 2 is same as c =\nc|2\n\nexample\ntry the following example to understand all the assignment operators available\nin c:\n#include <stdio.h>\n\nmain()\n{\nint a = 21;\nint c ;\n\nc =\n\na;\n\nprintf("line 1 - =\n\nc +=\n\noperator example, value of c = %d\\n", c );\n\na;\n\nprintf("line 2 - += operator example, value of c = %d\\n", c );\n\nc -=\n\na;\n\nprintf("line 3 - -= operator example, value of c = %d\\n", c );\n\nc *=\n\na;\n\nprintf("line 4 - *= operator example, value of c = %d\\n", c );\n\n38\n\nc programming\n\nc /=\n\na;\n\nprintf("line 5 - /= operator example, value of c = %d\\n", c );\n\nc\n\n= 200;\n\nc %=\n\na;\n\nprintf("line 6 - %= operator example, value of c = %d\\n", c );\n\nc <<=\n\n2;\n\nprintf("line 7 - <<= operator example, value of c = %d\\n", c );\n\nc >>=\n\n2;\n\nprintf("line 8 - >>= operator example, value of c = %d\\n", c );\n\nc &=\n\n2;\n\nprintf("line 9 - &= operator example, value of c = %d\\n", c );\n\nc ^=\n\n2;\n\nprintf("line 10 - ^= operator example, value of c = %d\\n", c );\n\nc |=\n\n2;\n\nprintf("line 11 - |= operator example, value of c = %d\\n", c );\n\n}\nwhen you compile and execute the above program, it produces the following\nresult:\nline 1 - =\n\noperator example, value of c = 21\n\nline 2 - += operator example, value of c = 42\nline 3 - -= operator example, value of c = 21\nline 4 - *= operator example, value of c = 441\nline 5 - /= operator example, value of c = 21\nline 6 - %= operator example, value of c = 11\nline 7 - <<= operator example, value of c = 44\nline 8 - >>= operator example, value of c = 11\n39\n\nc programming\n\nline 9 - &= operator example, value of c = 2\nline 10 - ^= operator example, value of c = 0\nline 11 - |= operator example, value of c = 2\n\nmisc operators \xe2\x86\xa6 sizeof & ternary\nbesides the operators discussed above, there are a few other important\noperators including sizeof and ? : supported by the c language.'
p162
aS'\noperator\n\ndescription\n\nexample\n\nsizeof()\n\nreturns the size of a variable.'
p163
aS'\n\nsizeof(a), where a is\ninteger, will return 4.'
p164
aS'\n\n&\n\nreturns the address of a variable.'
p165
aS'\n\n&a; returns the actual\naddress\nof\nthe\nvariable.'
p166
aS'\n\n*\n\npointer to a variable.'
p167
aS'\n\n*a;\n\n?:\n\nconditional expression.'
p168
aS'\n\nif condition is true ?\nthen\nvalue\nx\n:\notherwise value y\n\nexample\ntry following example to understand all the miscellaneous operators available in\nc:\n#include <stdio.h>\n\nmain()\n{\nint a = 4;\nshort b;\ndouble c;\nint* ptr;\n\n/* example of sizeof operator */\n40\n\nc programming\n\nprintf("line 1 - size of variable a = %d\\n", sizeof(a) );\nprintf("line 2 - size of variable b = %d\\n", sizeof(b) );\nprintf("line 3 - size of variable c= %d\\n", sizeof(c) );\n\n/* example of & and * operators */\nptr = &a;\n\n/* \'ptr\' now contains the address of \'a\'*/\n\nprintf("value of a is\n\n%d\\n", a);\n\nprintf("*ptr is %d.\\n", *ptr);\n\n/* example of ternary operator */\na = 10;\nb = (a == 1) ? 20: 30;\nprintf( "value of b is %d\\n", b );\n\nb = (a == 10) ? 20: 30;\nprintf( "value of b is %d\\n", b );\n}\nwhen you compile and execute the above program, it produces the following\nresult:\nvalue of a is\n\n4\n\n*ptr is 4.'
p169
aS'\nvalue of b is 30\nvalue of b is 20\n\noperators precedence in c\noperator precedence determines the grouping of terms in an expression and\ndecides how an expression is evaluated. certain operators have higher\nprecedence than others; for example, the multiplication operator has a higher\nprecedence than the addition operator.'
p170
aS'\nfor example, x = 7 + 3 * 2; here, x is assigned 13, not 20 because operator *\nhas a higher precedence than +, so it first gets multiplied with 3*2 and then\nadds into 7.'
p171
aS'\nhere, operators with the highest precedence appear at the top of the table,\nthose with the lowest appear at the bottom. within an expression, higher\nprecedence operators will be evaluated first.'
p172
aS'\n41\n\nc programming\n\ncategory\n\noperator\n\nassociativity\n\npostfix\n\n() [] -> . ++ - -\n\nleft to right\n\nunary\n\n+ - ! ~ ++ - - (type)* & sizeof\n\nright to left\n\nmultiplicative\n\n*/%\n\nleft to right\n\nadditive\n\n+-\n\nleft to right\n\nshift\n\n<< >>\n\nleft to right\n\nrelational\n\n< <= > >=\n\nleft to right\n\nequality\n\n== !=\n\nleft to right\n\nbitwise and\n\n&\n\nleft to right\n\nbitwise xor\n\n^\n\nleft to right\n\nbitwise or\n\n|\n\nleft to right\n\nlogical and\n\n&&\n\nleft to right\n\nlogical or\n\n||\n\nleft to right\n\nconditional\n\n?:\n\nright to left\n\nassignment\n\n= += -= *= /= %=>>= <<= &= ^= |=\n\nright to left\n\ncomma\n\n,\n\nleft to right\n\nexample\n42\n\nc programming\ntry the following example to understand operator precedence in c:\n#include <stdio.h>\n\nmain()\n{\nint a = 20;\nint b = 10;\nint c = 15;\nint d = 5;\nint e;\n\ne = (a + b) * c / d;\n\n// ( 30 * 15 ) / 5\n\nprintf("value of (a + b) * c / d is : %d\\n",\n\ne = ((a + b) * c) / d;\n\n// (30 * 15 ) / 5\n\nprintf("value of ((a + b) * c) / d is\n\ne = (a + b) * (c / d);\n\n: %d\\n" ,\n\ne );\n\n// (30) * (15/5)\n\nprintf("value of (a + b) * (c / d) is\n\ne = a + (b * c) / d;\n\ne );\n\n//\n\n: %d\\n",\n\ne );\n\n20 + (150/5)\n\nprintf("value of a + (b * c) / d is\n\n: %d\\n" ,\n\ne );\n\nreturn 0;\n}\nwhen you compile and execute the above program, it produces the following\nresult:\nvalue of (a + b) * c / d is : 90\nvalue of ((a + b) * c) / d is\n\n: 90\n\nvalue of (a + b) * (c / d) is\n\n: 90\n\nvalue of a + (b * c) / d is\n\n: 50\n\n43\n\nc programming\n\n44\n\nc programming\n\n10. decision making\n\ndecision-making structures require that the programmer specifies one or more\nconditions to be evaluated or tested by the program, along with a statement or\nstatements to be executed if the condition is determined to be true, and\noptionally, other statements to be executed if the condition is determined to be\nfalse.'
p173
aS'\nshown below is the general form of a typical decision-making structure found in\nmost of the programming languages:\n\nc programming language assumes any non-zero and non-null values as true,\nand if it is either zero or null, then it is assumed as false value.'
p174
aS'\nc programming language provides the following types of decision-making\nstatements.'
p175
aS'\nstatement\n\ndescription\n\nif statement\n\nan if statement consists of a boolean expression\nfollowed by one or more statements.'
p176
aS'\n\nif...else statement\n\nan if statement can be followed by an\noptional else statement, which executes when\n\n45\n\nc programming\n\nthe boolean expression is false.'
p177
aS'\nnested if statements\n\nyou can use one if or else if statement inside\nanother if or else if statement(s).'
p178
aS'\n\nswitch statement\n\na switch statement allows a variable to be tested\nfor equality against a list of values.'
p179
aS'\n\nnested switch statements\n\nyou can use one switch statement inside another\nswitch statement(s).'
p180
aS'\n\nif statement\nan if statement consists of a boolean expression followed by one or more\nstatements.'
p181
aS'\n\nsyntax\nthe syntax of an \xe2\x80\x98if\xe2\x80\x99 statement in c programming language is:\nif(boolean_expression)\n{\n/* statement(s) will execute if the boolean expression is true */\n}\nif the boolean expression evaluates to true, then the block of code inside the \xe2\x80\x98if\xe2\x80\x99\nstatement will be executed. if the boolean expression evaluates to false, then\nthe first set of code after the end of the \xe2\x80\x98if\xe2\x80\x99 statement (after the closing curly\nbrace) will be executed.'
p182
aS'\nc programming language assumes any non-zero and non-null values\nas true and if it is either zero or null, then it is assumed as false value.'
p183
aS'\n\nflow diagram\n\n46\n\nc programming\n\nexample\n#include <stdio.h>\n\nint main ()\n{\n/* local variable definition */\nint a = 10;\n\n/* check the boolean condition using if statement */\nif( a < 20 )\n{\n/* if condition is true then print the following */\nprintf("a is less than 20\\n" );\n}\nprintf("value of a is : %d\\n", a);\n\nreturn 0;\n}\nwhen the above code is compiled and executed, it produces the following result:\na is less than 20;\n47\n\nc programming\n\nvalue of a is : 10\n\nif\xe2\x80\xa6else statement\nan if statement can be followed by an optional else statement, which executes\nwhen the boolean expression is false.'
p184
aS'\n\nsyntax\nthe syntax of an if...else statement in c programming language is:\nif(boolean_expression)\n{\n/* statement(s) will execute if the boolean expression is true */\n}\nelse\n{\n/* statement(s) will execute if the boolean expression is false */\n}\nif the boolean expression evaluates to true, then the if block will be executed,\notherwise, the else block will be executed.'
p185
aS'\nc programming language assumes any non-zero and non-null values as true,\nand if it is either zero or null, then it is assumed as false value.'
p186
aS'\n\nflow diagram\n\n48\n\nc programming\n\nexample\n#include <stdio.h>\n\nint main ()\n{\n/* local variable definition */\nint a = 100;\n\n/* check the boolean condition */\nif( a < 20 )\n{\n/* if condition is true then print the following */\nprintf("a is less than 20\\n" );\n}\nelse\n{\n/* if condition is false then print the following */\nprintf("a is not less than 20\\n" );\n}\nprintf("value of a is : %d\\n", a);\n\nreturn 0;\n}\nwhen the above code is compiled and executed, it produces the following result:\na is not less than 20;\nvalue of a is : 100\n\nif...else if...else statement\nan if statement can be followed by an optional else if...else statement, which is\nvery useful to test various conditions using single if...else if statement.'
p187
aS"\nwhen using if\xe2\x80\xa6else if\xe2\x80\xa6else statements, there are few points to keep in mind:\n\xef\x82\xb7\n\nan if can have zero or one else's and it must come after any else if's."
p188
aS"\n\n\xef\x82\xb7\n\nan if can have zero to many else if's and they must come before the else."
p189
aS"\n49\n\nc programming\n\xef\x82\xb7\n\nonce an else if succeeds, none of the remaining else if's or else's will be\ntested."
p190
aS'\n\nsyntax\nthe syntax of an if...else if...else statement in c programming language is:\nif(boolean_expression 1)\n{\n/* executes when the boolean expression 1 is true */\n}\nelse if( boolean_expression 2)\n{\n/* executes when the boolean expression 2 is true */\n}\nelse if( boolean_expression 3)\n{\n/* executes when the boolean expression 3 is true */\n}\nelse\n{\n/* executes when the none of the above condition is true */\n}\n\nexample\n#include <stdio.h>\n\nint main ()\n{\n/* local variable definition */\nint a = 100;\n\n/* check the boolean condition */\nif( a == 10 )\n{\n/* if condition is true then print the following */\n50\n\nc programming\n\nprintf("value of a is 10\\n" );\n}\nelse if( a == 20 )\n{\n/* if else if condition is true */\nprintf("value of a is 20\\n" );\n}\nelse if( a == 30 )\n{\n/* if else if condition is true\n\n*/\n\nprintf("value of a is 30\\n" );\n}\nelse\n{\n/* if none of the conditions is true */\nprintf("none of the values is matching\\n" );\n}\nprintf("exact value of a is: %d\\n", a );\n\nreturn 0;\n}\nwhen the above code is compiled and executed, it produces the following result:\nnone of the values is matching\nexact value of a is: 100\n\nnested if statements\nit is always legal in c programming to nest if-else statements, which means you\ncan use one if or else if statement inside another if or else if statement(s).'
p191
aS'\n\nsyntax\nthe syntax for a nested if statement is as follows:\nif( boolean_expression 1)\n{\n51\n\nc programming\n\n/* executes when the boolean expression 1 is true */\nif(boolean_expression 2)\n{\n/* executes when the boolean expression 2 is true */\n}\n}\nyou can nest else if...else in the similar way as you have nested if statements.'
p192
aS'\n\nexample\n#include <stdio.h>\n\nint main ()\n{\n/* local variable definition */\nint a = 100;\nint b = 200;\n\n/* check the boolean condition */\nif( a == 100 )\n{\n/* if condition is true then check the following */\nif( b == 200 )\n{\n/* if condition is true then print the following */\nprintf("value of a is 100 and b is 200\\n" );\n}\n}\nprintf("exact value of a is : %d\\n", a );\nprintf("exact value of b is : %d\\n", b );\n\nreturn 0;\n}\nwhen the above code is compiled and executed, it produces the following result:\n52\n\nc programming\n\nvalue of a is 100 and b is 200\nexact value of a is : 100\nexact value of b is : 200\n\nswitch statement\na switch statement allows a variable to be tested for equality against a list of\nvalues. each value is called a case, and the variable being switched on is\nchecked for each switch case.'
p193
aS'\n\nsyntax\nthe syntax for a switch statement in c programming language is as follows:\nswitch(expression){\ncase constant-expression\n\n:\n\nstatement(s);\nbreak; /* optional */\ncase constant-expression\n\n:\n\nstatement(s);\nbreak; /* optional */\n\n/* you can have any number of case statements */\ndefault : /* optional */\nstatement(s);\n}\nthe following rules apply to a switch statement:\n\xef\x82\xb7\n\nthe expression used in a switch statement must have an integral or\nenumerated type, or be of a class type in which the class has a single\nconversion function to an integral or enumerated type.'
p194
aS'\n\n\xef\x82\xb7\n\nyou can have any number of case statements within a switch. each case is\nfollowed by the value to be compared to and a colon.'
p195
aS'\n\n\xef\x82\xb7\n\nthe constant-expression for a case must be the same data type as the\nvariable in the switch, and it must be a constant or a literal.'
p196
aS'\n\n\xef\x82\xb7\n\nwhen the variable being switched on is equal to a case, the statements\nfollowing that case will execute until a break statement is reached.'
p197
aS'\n\n\xef\x82\xb7\n\nwhen a break statement is reached, the switch terminates, and the flow\nof control jumps to the next line following the switch statement.'
p198
aS'\n53\n\nc programming\n\xef\x82\xb7\n\nnot every case needs to contain a break. if no break appears, the flow of\ncontrol will fall through to subsequent cases until a break is reached.'
p199
aS'\n\n\xef\x82\xb7\n\na switch statement can have an optional default case, which must\nappear at the end of the switch. the default case can be used for\nperforming a task when none of the cases is true. no break is needed in\nthe default case.'
p200
aS'\n\nflow diagram\n\nexample\n#include <stdio.h>\n\nint main ()\n{\n/* local variable definition */\nchar grade = \'b\';\n\nswitch(grade)\n{\ncase \'a\' :\n54\n\nc programming\n\nprintf("excellent!\\n" );\nbreak;\ncase \'b\' :\ncase \'c\' :\nprintf("well done\\n" );\nbreak;\ncase \'d\' :\nprintf("you passed\\n" );\nbreak;\ncase \'f\' :\nprintf("better try again\\n" );\nbreak;\ndefault :\nprintf("invalid grade\\n" );\n}\nprintf("your grade is\n\n%c\\n", grade );\n\nreturn 0;\n}\nwhen the above code is compiled and executed, it produces the following result:\nwell done\nyour grade is b\n\nnested switch statements\nit is possible to have a switch as a part of the statement sequence of an outer\nswitch. even if the case constants of the inner and outer switch contain common\nvalues, no conflicts will arise.'
p201
aS'\n\nsyntax\nthe syntax for a nested switch statement is as follows:\nswitch(ch1) {\ncase \'a\':\nprintf("this a is part of outer switch" );\n\n55\n\nc programming\n\nswitch(ch2) {\ncase \'a\':\nprintf("this a is part of inner switch" );\nbreak;\ncase \'b\': /* case code */\n}\nbreak;\ncase \'b\': /* case code */\n}\n\nexample\n#include <stdio.h>\n\nint main ()\n{\n/* local variable definition */\nint a = 100;\nint b = 200;\n\nswitch(a) {\ncase 100:\nprintf("this is part of outer switch\\n", a );\nswitch(b) {\ncase 200:\nprintf("this is part of inner switch\\n", a );\n}\n}\nprintf("exact value of a is : %d\\n", a );\nprintf("exact value of b is : %d\\n", b );\n\nreturn 0;\n}\n\nwhen the above code is compiled and executed, it produces the following result:\n56\n\nc programming\n\nthis is part of outer switch\nthis is part of inner switch\nexact value of a is : 100\nexact value of b is : 200\n\nthe ? : operator:\nwe have covered conditional operator ? : in the previous chapter which can be\nused to replace if...else statements. it has the following general form:\nexp1 ? exp2 : exp3;\nwhere exp1, exp2, and exp3 are expressions. notice the use and placement of\nthe colon.'
p202
aS'\nthe value of a ? expression is determined like this:\n1. exp1 is evaluated. if it is true, then exp2 is evaluated and becomes the\nvalue of the entire ? expression.'
p203
aS'\n2. if exp1 is false, then exp3 is evaluated and its value becomes the value of\nthe expression.'
p204
aS'\n\n57\n\n11. loops\n\nc programming\n\nyou may encounter situations when a block of code needs to be executed\nseveral number of times. in general, statements are executed sequentially: the\nfirst statement in a function is executed first, followed by the second, and so on.'
p205
aS'\nprogramming languages provide various control structures that allow for more\ncomplicated execution paths.'
p206
aS'\na loop statement allows us to execute a statement or group of statements\nmultiple times. given below is the general form of a loop statement in most of\nthe programming languages:\n\nc programming language provides the following types of loops to handle looping\nrequirements.'
p207
aS'\nloop type\n\ndescription\n\nwhile loop\n\nrepeats a statement or group of statements while a\ngiven condition is true. it tests the condition before\nexecuting the loop body.'
p208
aS'\n\nfor loop\n\nexecutes a sequence of statements multiple times and\nabbreviates the code that manages the loop variable.'
p209
aS'\n58\n\nc programming\n\ndo...while loop\n\nit is more like a while statement, except that it tests\nthe condition at the end of the loop body.'
p210
aS'\n\nnested loops\n\nyou can use one or more loops inside any other while,\nfor, or do..while loop.'
p211
aS'\n\nwhile loop\na while loop in c programming repeatedly executes a target statement as long\nas a given condition is true.'
p212
aS'\n\nsyntax\nthe syntax of a while loop in c programming language is:\nwhile(condition)\n{\nstatement(s);\n}\nhere, statement(s) may be a single statement or a block of statements.'
p213
aS'\nthe condition may be any expression, and true is any nonzero value. the loop\niterates while the condition is true.'
p214
aS'\nwhen the condition becomes false, the program control passes to the line\nimmediately following the loop.'
p215
aS'\n\nflow diagram\n\n59\n\nc programming\n\nhere, the key point to note is that a while loop might not execute at all. when\nthe condition is tested and the result is false, the loop body will be skipped and\nthe first statement after the while loop will be executed.'
p216
aS'\n\nexample\n#include <stdio.h>\n\nint main ()\n{\n/* local variable definition */\nint a = 10;\n\n/* while loop execution */\nwhile( a < 20 )\n{\nprintf("value of a: %d\\n", a);\na++;\n}\n\n60\n\nc programming\n\nreturn 0;\n}\nwhen the above code is compiled and executed, it produces the following result:\nvalue of a: 10\nvalue of a: 11\nvalue of a: 12\nvalue of a: 13\nvalue of a: 14\nvalue of a: 15\nvalue of a: 16\nvalue of a: 17\nvalue of a: 18\nvalue of a: 19\n\nfor loop\na for loop is a repetition control structure that allows you to efficiently write a\nloop that needs to execute a specific number of times.'
p217
aS'\n\nsyntax\nthe syntax of a for loop in c programming language is:\nfor ( init; condition; increment )\n{\nstatement(s);\n}\nhere is the flow of control in a \xe2\x80\x98for\xe2\x80\x99 loop:\n1. the init step is executed first, and only once. this step allows you to\ndeclare and initialize any loop control variables. you are not required to\nput a statement here, as long as a semicolon appears.'
p218
aS'\n2. next, the condition is evaluated. if it is true, the body of the loop is\nexecuted. if it is false, the body of the loop does not execute and the flow\nof control jumps to the next statement just after the \xe2\x80\x98for\xe2\x80\x99 loop.'
p219
aS'\n3. after the body of the \xe2\x80\x98for\xe2\x80\x99 loop executes, the flow of control jumps back up\nto the increment statement. this statement allows you to update any\nloop control variables. this statement can be left blank, as long as a\nsemicolon appears after the condition.'
p220
aS'\n61\n\nc programming\n4. the condition is now evaluated again. if it is true, the loop executes and\nthe process repeats itself (body of loop, then increment step, and then\nagain condition). after the condition becomes false, the \xe2\x80\x98for\xe2\x80\x99 loop\nterminates.'
p221
aS'\n\nflow diagram\n\nexample\n#include <stdio.h>\n\nint main ()\n{\n/* for loop execution */\nfor( int a = 10; a < 20; a = a + 1 )\n{\nprintf("value of a: %d\\n", a);\n62\n\nc programming\n\n}\n\nreturn 0;\n}\nwhen the above code is compiled and executed, it produces the following result:\nvalue of a: 10\nvalue of a: 11\nvalue of a: 12\nvalue of a: 13\nvalue of a: 14\nvalue of a: 15\nvalue of a: 16\nvalue of a: 17\nvalue of a: 18\nvalue of a: 19\n\ndo\xe2\x80\xa6while loop\nunlike for and while loops, which test the loop condition at the top of the loop,\nthe do...while loop in c programming checks its condition at the bottom of the\nloop.'
p222
aS'\na do...while loop is similar to a while loop, except the fact that it is guaranteed\nto execute at least one time.'
p223
aS'\n\nsyntax\nthe syntax of a do...while loop in c programming language is:\ndo\n{\nstatement(s);\n\n}while( condition );\nnotice that the conditional expression appears at the end of the loop, so the\nstatement(s) in the loop executes once before the condition is tested.'
p224
aS'\n\n63\n\nc programming\nif the condition is true, the flow of control jumps back up to do, and the\nstatement(s) in the loop executes again. this process repeats until the given\ncondition becomes false.'
p225
aS'\n\nflow diagram\n\nexample\n#include <stdio.h>\n\nint main ()\n{\n/* local variable definition */\nint a = 10;\n\n/* do loop execution */\ndo\n{\nprintf("value of a: %d\\n", a);\na = a + 1;\n}while( a < 20 );\n\nreturn 0;\n\n64\n\nc programming\n\n}\nwhen the above code is compiled and executed, it produces the following result:\nvalue of a: 10\nvalue of a: 11\nvalue of a: 12\nvalue of a: 13\nvalue of a: 14\nvalue of a: 15\nvalue of a: 16\nvalue of a: 17\nvalue of a: 18\nvalue of a: 19\n\nnested loops\nc programming allows to use one loop inside another loop. the following section\nshows a few examples to illustrate the concept.'
p226
aS'\n\nsyntax\nthe syntax for a nested for loop statement in c is as follows:\nfor ( init; condition; increment )\n{\nfor ( init; condition; increment )\n{\nstatement(s);\n}\nstatement(s);\n}\nthe syntax for a nested while loop statement in c programming language is as\nfollows:\nwhile(condition)\n{\nwhile(condition)\n{\n65\n\nc programming\n\nstatement(s);\n}\nstatement(s);\n}\nthe syntax for a nested do...while loop statement in c programming language\nis as follows:\ndo\n{\nstatement(s);\ndo\n{\nstatement(s);\n}while( condition );\n\n}while( condition );\na final note on loop nesting is that you can put any type of loop inside any other\ntype of loop. for example, a \xe2\x80\x98for\xe2\x80\x99 loop can be inside a \xe2\x80\x98while\xe2\x80\x99 loop or vice versa.'
p227
aS'\n\nexample\nthe following program uses a nested for loop to find the prime numbers from 2\nto 100:\n#include <stdio.h>\n\nint main ()\n{\n/* local variable definition */\nint i, j;\n\nfor(i=2; i<100; i++) {\nfor(j=2; j <= (i/j); j++)\nif(!(i%j)) break;\n\n// if factor found, not prime\n\nif(j > (i/j)) printf("%d is prime\\n", i);\n}\n\n66\n\nc programming\n\nreturn 0;\n}\nwhen the above code is compiled and executed, it produces the following result:\n2 is prime\n3 is prime\n5 is prime\n7 is prime\n11 is prime\n13 is prime\n17 is prime\n19 is prime\n23 is prime\n29 is prime\n31 is prime\n37 is prime\n41 is prime\n43 is prime\n47 is prime\n53 is prime\n59 is prime\n61 is prime\n67 is prime\n71 is prime\n73 is prime\n79 is prime\n83 is prime\n89 is prime\n97 is prime\n\nloop control statements\nloop control statements change execution from its normal sequence. when\nexecution leaves a scope, all automatic objects that were created in that scope\nare destroyed.'
p228
aS'\n67\n\nc programming\nc supports the following control statements.'
p229
aS'\ncontrol statement\n\ndescription\n\nbreak statement\n\nterminates the loop or switch statement and\ntransfers execution to the statement immediately\nfollowing the loop or switch.'
p230
aS'\n\ncontinue statement\n\ncauses the loop to skip the remainder of its body and\nimmediately retest its condition prior to reiterating.'
p231
aS'\n\ngoto statement\n\ntransfers control to the labeled statement.'
p232
aS'\n\nbreak statement\nthe break statement in c programming has the following two usages:\n\xef\x82\xb7\n\nwhen a break statement is encountered inside a loop, the loop is\nimmediately terminated and the program control resumes at the next\nstatement following the loop.'
p233
aS'\n\n\xef\x82\xb7\n\nit can be used to terminate a case in the switch statement (covered in\nthe next chapter).'
p234
aS'\n\nif you are using nested loops, the break statement will stop the execution of the\ninnermost loop and start executing the next line of code after the block.'
p235
aS'\n\nsyntax\nthe syntax for a break statement in c is as follows:\nbreak;\n\nflow diagram\n\n68\n\nc programming\n\nexample\n#include <stdio.h>\n\nint main ()\n{\n/* local variable definition */\nint a = 10;\n\n/* while loop execution */\nwhile( a < 20 )\n{\nprintf("value of a: %d\\n", a);\na++;\nif( a > 15)\n{\n/* terminate the loop using break statement */\nbreak;\n}\n}\n\n69\n\nc programming\n\nreturn 0;\n}\nwhen the above code is compiled and executed, it produces the following result:\nvalue of a: 10\nvalue of a: 11\nvalue of a: 12\nvalue of a: 13\nvalue of a: 14\nvalue of a: 15\n\ncontinue statement\nthe continue statement in c programming works somewhat like the break\nstatement. instead of forcing termination, it forces the next iteration of the loop\nto take place, skipping any code in between.'
p236
aS'\nfor the for loop, continue statement causes the conditional test and increment\nportions of the loop to execute. for the while and do...while loops, continue\nstatement causes the program control to pass to the conditional tests.'
p237
aS'\n\nsyntax\nthe syntax for a continue statement in c is as follows:\ncontinue;\n\nflow diagram\n\n70\n\nc programming\n\nexample\n#include <stdio.h>\n\nint main ()\n{\n/* local variable definition */\nint a = 10;\n\n/* do loop execution */\ndo\n{\nif( a == 15)\n{\n/* skip the iteration */\na = a + 1;\ncontinue;\n}\nprintf("value of a: %d\\n", a);\na++;\n\n71\n\nc programming\n\n}while( a < 20 );\n\nreturn 0;\n}\nwhen the above code is compiled and executed, it produces the following result:\nvalue of a: 10\nvalue of a: 11\nvalue of a: 12\nvalue of a: 13\nvalue of a: 14\nvalue of a: 16\nvalue of a: 17\nvalue of a: 18\nvalue of a: 19\n\ngoto statement\na goto statement in c programming provides an unconditional jump from the\n\xe2\x80\x98goto\xe2\x80\x99 to a labeled statement in the same function.'
p238
aS'\nnote: use of goto statement is highly discouraged in any programming\nlanguage because it makes difficult to trace the control flow of a program,\nmaking the program hard to understand and hard to modify. any program that\nuses a goto can be rewritten to avoid them.'
p239
aS'\n\nsyntax\nthe syntax for a goto statement in c is as follows:\ngoto label;\n..'
p240
aS'\n.\nlabel: statement;\nhere label can be any plain text except c keyword and it can be set anywhere in\nthe c program above or below to goto statement.'
p241
aS'\n\n72\n\nc programming\n\nflow diagram\n\nexample\n#include <stdio.h>\n\nint main ()\n{\n/* local variable definition */\nint a = 10;\n\n/* do loop execution */\nloop:do\n{\nif( a == 15)\n{\n/* skip the iteration */\na = a + 1;\ngoto loop;\n}\nprintf("value of a: %d\\n", a);\na++;\n\n73\n\nc programming\n\n}while( a < 20 );\n\nreturn 0;\n}\nwhen the above code is compiled and executed, it produces the following result:\nvalue of a: 10\nvalue of a: 11\nvalue of a: 12\nvalue of a: 13\nvalue of a: 14\nvalue of a: 16\nvalue of a: 17\nvalue of a: 18\nvalue of a: 19\n\nthe infinite loop\na loop becomes an infinite loop if a condition never becomes false. the for loop\nis traditionally used for this purpose. since none of the three expressions that\nform the \xe2\x80\x98for\xe2\x80\x99 loop are required, you can make an endless loop by leaving the\nconditional expression empty.'
p242
aS'\n#include <stdio.h>\n\nint main ()\n{\n\nfor( ; ; )\n{\nprintf("this loop will run forever.\\n");\n}\n\nreturn 0;\n}\n\n74\n\nc programming\nwhen the conditional expression is absent, it is assumed to be true. you may\nhave an initialization and increment expression, but c programmers more\ncommonly use the for(;;) construct to signify an infinite loop.'
p243
aS'\nnote: you can terminate an infinite loop by pressing ctrl + c keys.'
p244
aS'\n\n75\n\n12. functions\n\nc programming\n\na function is a group of statements that together perform a task. every c\nprogram has at least one function, which is main(), and all the most trivial\nprograms can define additional functions.'
p245
aS'\nyou can divide up your code into separate functions. how you divide up your\ncode among different functions is up to you, but logically the division is such\nthat each function performs a specific task.'
p246
aS"\na function declaration tells the compiler about a function's name, return type,\nand parameters. a function definition provides the actual body of the function."
p247
aS'\nthe c standard library provides numerous built-in functions that your program\ncan call. for example, strcat() to concatenate two strings, memcpy() to copy\none memory location to another location, and many more functions.'
p248
aS'\na function can also be referred as a method or a sub-routine or a procedure, etc.'
p249
aS'\n\ndefining a function\nthe general form of a function definition in c programming language is as\nfollows:\nreturn_type function_name( parameter list )\n{\nbody of the function\n}\na function definition in c programming consists of a function header and a\nfunction body. here are all the parts of a function:\n\xef\x82\xb7\n\nreturn type: a function may return a value. the return_type is the\ndata type of the value the function returns. some functions perform the\ndesired operations without returning a value. in this case, the return_type\nis the keyword void.'
p250
aS'\n\n\xef\x82\xb7\n\nfunction name: this is the actual name of the function. the function\nname and the parameter list together constitute the function signature.'
p251
aS'\n\n\xef\x82\xb7\n\nparameters: a parameter is like a placeholder. when a function is\ninvoked, you pass a value to the parameter. this value is referred to as\nactual parameter or argument. the parameter list refers to the type,\norder, and number of the parameters of a function. parameters are\noptional; that is, a function may contain no parameters.'
p252
aS'\n\n76\n\nc programming\n\xef\x82\xb7\n\nfunction body: the function body contains a collection of statements\nthat define what the function does.'
p253
aS'\n\nexample\ngiven below is the source code for a function called max(). this function takes\ntwo parameters num1 and num2 and returns the maximum value between the\ntwo:\n/* function returning the max between two numbers */\nint max(int num1, int num2)\n{\n/* local variable declaration */\nint result;\n\nif (num1 > num2)\nresult = num1;\nelse\nresult = num2;\n\nreturn result;\n}\n\nfunction declarations\na function declaration tells the compiler about a function name and how to call\nthe function. the actual body of the function can be defined separately.'
p254
aS'\na function declaration has the following parts:\nreturn_type function_name( parameter list );\nfor the above defined function max(),the function declaration is as follows:\nint max(int num1, int num2);\nparameter names are not important in function declaration, only their type is\nrequired, so the following is also a valid declaration:\nint max(int, int);\nfunction declaration is required when you define a function in one source file\nand you call that function in another file. in such case, you should declare the\nfunction at the top of the file calling the function.'
p255
aS'\n77\n\nc programming\n\ncalling a function\nwhile creating a c function, you give a definition of what the function has to do.'
p256
aS'\nto use a function, you will have to call that function to perform the defined task.'
p257
aS'\nwhen a program calls a function, the program control is transferred to the called\nfunction. a called function performs a defined task and when its return\nstatement is executed or when its function-ending closing brace is reached, it\nreturns the program control back to the main program.'
p258
aS'\nto call a function, you simply need to pass the required parameters along with\nthe function name, and if the function returns a value, then you can store the\nreturned value. for example:\n#include <stdio.h>\n\n/* function declaration */\nint max(int num1, int num2);\n\nint main ()\n{\n/* local variable definition */\nint a = 100;\nint b = 200;\nint ret;\n\n/* calling a function to get max value */\nret = max(a, b);\n\nprintf( "max value is : %d\\n", ret );\n\nreturn 0;\n}\n\n/* function returning the max between two numbers */\nint max(int num1, int num2)\n{\n/* local variable declaration */\nint result;\n78\n\nc programming\n\nif (num1 > num2)\nresult = num1;\nelse\nresult = num2;\n\nreturn result;\n}\nwe have kept max()along with main() and compiled the source code. while\nrunning the final executable, it would produce the following result:\nmax value is : 200\n\nfunction arguments\nif a function is to use arguments, it must declare variables that accept the\nvalues of the arguments. these variables are called the formal parameters of\nthe function.'
p259
aS'\nformal parameters behave like other local variables inside the function and are\ncreated upon entry into the function and destroyed upon exit.'
p260
aS'\nwhile calling a function, there are two ways in which arguments can be passed\nto a function:\ncall type\n\ndescription\n\ncall by value\n\nthis method copies the actual value of an argument\ninto the formal parameter of the function. in this case,\nchanges made to the parameter inside the function\nhave no effect on the argument.'
p261
aS'\n\ncall by reference\n\nthis method copies the address of an argument into\nthe formal parameter. inside the function, the address\nis used to access the actual argument used in the call.'
p262
aS'\nthis means that changes made to the parameter affect\nthe argument.'
p263
aS'\n\n79\n\nc programming\n\ncall by value\nthe call by value method of passing arguments to a function copies the actual\nvalue of an argument into the formal parameter of the function. in this case,\nchanges made to the parameter inside the function have no effect on the\nargument.'
p264
aS'\nby default, c programming uses call by value to pass arguments. in general, it\nmeans the code within a function cannot alter the arguments used to call the\nfunction. consider the function swap() definition as follows.'
p265
aS'\n/* function definition to swap the values */\nvoid swap(int x, int y)\n{\nint temp;\n\ntemp = x; /* save the value of x */\nx = y;\n\n/* put y into x */\n\ny = temp; /* put temp into y */\n\nreturn;\n}\nnow, let us call the function swap() by passing actual values as in the following\nexample:\n#include <stdio.h>\n\n/* function declaration */\nvoid swap(int x, int y);\n\nint main ()\n{\n/* local variable definition */\nint a = 100;\nint b = 200;\n\nprintf("before swap, value of a : %d\\n", a );\nprintf("before swap, value of b : %d\\n", b );\n80\n\nc programming\n\n/* calling a function to swap the values */\nswap(a, b);\n\nprintf("after swap, value of a : %d\\n", a );\nprintf("after swap, value of b : %d\\n", b );\n\nreturn 0;\n}\nlet us put the above code in a single c file, compile and execute it, it will\nproduce the following result:\nbefore swap, value of a :100\nbefore swap, value of b :200\nafter swap, value of a :100\nafter swap, value of b :200\nit shows that there are no changes in the values, though they had been changed\ninside the function.'
p266
aS'\n\ncall by reference\nthe call by reference method of passing arguments to a function copies the\naddress of an argument into the formal parameter. inside the function, the\naddress is used to access the actual argument used in the call. it means the\nchanges made to the parameter affect the passed argument.'
p267
aS'\nto pass a value by reference, argument pointers are passed to the functions just\nlike any other value. so accordingly, you need to declare the function\nparameters as pointer types as in the following function swap(), which\nexchanges the values of the two integer variables pointed to, by their\narguments.'
p268
aS'\n/* function definition to swap the values */\nvoid swap(int *x, int *y)\n{\nint temp;\ntemp = *x;\n\n/* save the value at address x */\n\n*x = *y;\n\n/* put y into x */\n81\n\nc programming\n\n*y = temp;\n\n/* put temp into y */\n\nreturn;\n}\nlet us now call the function swap() by passing values by reference as in the\nfollowing example:\n#include <stdio.h>\n\n/* function declaration */\nvoid swap(int *x, int *y);\n\nint main ()\n{\n/* local variable definition */\nint a = 100;\nint b = 200;\n\nprintf("before swap, value of a : %d\\n", a );\nprintf("before swap, value of b : %d\\n", b );\n\n/* calling a function to swap the values.'
p269
aS'\n* &a indicates pointer to a i.e. address of variable a and\n* &b indicates pointer to b i.e. address of variable b.'
p270
aS'\n*/\nswap(&a, &b);\n\nprintf("after swap, value of a : %d\\n", a );\nprintf("after swap, value of b : %d\\n", b );\n\nreturn 0;\n}\nlet us put the above code in a single c file, compile and execute it, to produce\nthe following result:\n82\n\nc programming\n\nbefore swap, value of a :100\nbefore swap, value of b :200\nafter swap, value of a :200\nafter swap, value of b :100\nit shows that the change has reflected outside the function as well, unlike call\nby value where the changes do not reflect outside the function.'
p271
aS'\nby default, c uses call by value to pass arguments. in general, it means the\ncode within a function cannot alter the arguments used to call the function.'
p272
aS'\n\n83\n\n13. scope rules\n\nc programming\n\na scope in any programming is a region of the program where a defined variable\ncan have its existence and beyond that variable it cannot be accessed. there are\nthree places where variables can be declared in c programming language:\n\xef\x82\xb7\n\ninside a function or a block which is called local variables,\n\n\xef\x82\xb7\n\noutside of all functions which is called global variables.'
p273
aS'\n\n\xef\x82\xb7\n\nin the definition of function parameters which are called formal\nparameters.'
p274
aS'\n\nlet us understand what are local and global variables, and formal parameters.'
p275
aS'\n\nlocal variables\nvariables that are declared inside a function or block are called local variables.'
p276
aS'\nthey can be used only by statements that are inside that function or block of\ncode. local variables are not known to functions outside their own. the following\nexample shows how local variables are used. here all the variables a, b, and c\nare local to main() function.'
p277
aS'\n#include <stdio.h>\n\nint main ()\n{\n/* local variable declaration */\nint a, b;\nint c;\n\n/* actual initialization */\na = 10;\nb = 20;\nc = a + b;\n\nprintf ("value of a = %d, b = %d and c = %d\\n", a, b, c);\n\nreturn 0;\n84\n\nc programming\n\n}\n\nglobal variables\nglobal variables are defined outside a function, usually on top of the program.'
p278
aS'\nglobal variables hold their values throughout the lifetime of your program and\nthey can be accessed inside any of the functions defined for the program.'
p279
aS'\na global variable can be accessed by any function. that is, a global variable is\navailable for use throughout your entire program after its declaration. the\nfollowing program shows how global variables are used in a program.'
p280
aS'\n#include <stdio.h>\n\n/* global variable declaration */\nint g;\n\nint main ()\n{\n/* local variable declaration */\nint a, b;\n\n/* actual initialization */\na = 10;\nb = 20;\ng = a + b;\n\nprintf ("value of a = %d, b = %d and g = %d\\n", a, b, g);\n\nreturn 0;\n}\na program can have same name for local and global variables but the value of\nlocal variable inside a function will take preference. here is an example:\n#include <stdio.h>\n\n/* global variable declaration */\n85\n\nc programming\n\nint g = 20;\n\nint main ()\n{\n/* local variable declaration */\nint g = 10;\n\nprintf ("value of g = %d\\n",\n\ng);\n\nreturn 0;\n}\nwhen the above code is compiled and executed, it produces the following result:\nvalue of g = 10\n\nformal parameters\nformal parameters are treated as local variables with-in a function and they take\nprecedence over global variables. following is an example:\n#include <stdio.h>\n\n/* global variable declaration */\nint a = 20;\n\nint main ()\n{\n/* local variable declaration in main function */\nint a = 10;\nint b = 20;\nint c = 0;\n\nprintf ("value of a in main() = %d\\n",\n\na);\n\nc = sum( a, b);\nprintf ("value of c in main() = %d\\n",\n\nc);\n86\n\nc programming\n\nreturn 0;\n}\n\n/* function to add two integers */\nint sum(int a, int b)\n{\nprintf ("value of a in sum() = %d\\n",\n\na);\n\nprintf ("value of b in sum() = %d\\n",\n\nb);\n\nreturn a + b;\n}\nwhen the above code is compiled and executed, it produces the following result:\nvalue of a in main() = 10\nvalue of a in sum() = 10\nvalue of b in sum() = 20\nvalue of c in main() = 30\n\ninitializing local and global variables\nwhen a local variable is defined, it is not initialized by the system, you must\ninitialize it yourself. global variables are initialized automatically by the system\nwhen you define them, as follows:\ndata type\n\ninitial default value\n\nint\n\n0\n\nchar\n\n\'\\0\'\n\nfloat\n\n0\n\ndouble\n\n0\n\n87\n\nc programming\n\npointer\n\nnull\n\nit is a good programming practice to initialize variables properly, otherwise your\nprogram may produce unexpected results, because uninitialized variables will\ntake some garbage value already available at their memory location.'
p281
aS'\n\n88\n\n14. arrays\n\nc programming\n\narrays a kind of data structure that can store a fixed-size sequential collection of\nelements of the same type. an array is used to store a collection of data, but it\nis often more useful to think of an array as a collection of variables of the same\ntype.'
p282
aS'\ninstead of declaring individual variables, such as number0, number1, ..., and\nnumber99, you declare one array variable such as numbers and use\nnumbers[0], numbers[1], and ..., numbers[99] to represent individual variables.'
p283
aS'\na specific element in an array is accessed by an index.'
p284
aS'\nall arrays consist of contiguous memory locations. the lowest address\ncorresponds to the first element and the highest address to the last element.'
p285
aS'\n\ndeclaring arrays\nto declare an array in c, a programmer specifies the type of the elements and\nthe number of elements required by an array as follows:\ntype arrayname [ arraysize ];\nthis is called a single-dimensional array. the arraysize must be an integer\nconstant greater than zero and type can be any valid c data type. for example,\nto declare a 10-element array called balance of type double, use this statement:\ndouble balance[10];\nhere, balance is a variable array which is sufficient to hold up to 10 double\nnumbers.'
p286
aS'\n\ninitializing arrays\nyou can initialize an array in c either one by one or using a single statement as\nfollows:\ndouble balance[5] = {1000.0, 2.0, 3.4, 7.0, 50.0};\n\n89\n\nc programming\nthe number of values between braces { } cannot be larger than the number of\nelements that we declare for the array between square brackets [ ].'
p287
aS'\nif you omit the size of the array, an array just big enough to hold the\ninitialization is created. therefore, if you write:\ndouble balance[] = {1000.0, 2.0, 3.4, 7.0, 50.0};\nyou will create exactly the same array as you did in the previous example.'
p288
aS'\nfollowing is an example to assign a single element of the array:\nbalance[4] = 50.0;\nthe above statement assigns the 5th element in the array with a value of 50.0.'
p289
aS'\nall arrays have 0 as the index of their first element which is also called the base\nindex and the last index of an array will be total size of the array minus 1.'
p290
aS'\nshown below is the pictorial representation of the array we discussed above:\n\naccessing array elements\nan element is accessed by indexing the array name. this is done by placing the\nindex of the element within square brackets after the name of the array. for\nexample:\ndouble salary = balance[9];\nthe above statement will take the 10th element from the array and assign the\nvalue to salary variable. the following example shows how to use all the three\nabove-mentioned concepts viz. declaration, assignment, and accessing arrays:\n#include <stdio.h>\n\nint main ()\n{\nint n[ 10 ]; /* n is an array of 10 integers */\nint i,j;\n\n/* initialize elements of array n to 0 */\nfor ( i = 0; i < 10; i++ )\n{\n90\n\nc programming\n\nn[ i ] = i + 100;\n\n/* set element at location i to i + 100 */\n\n}\n\n/* output each array element\'s value */\nfor (j = 0; j < 10; j++ )\n{\nprintf("element[%d] = %d\\n", j, n[j] );\n}\n\nreturn 0;\n}\nwhen the above code is compiled and executed, it produces the following result:\nelement[0] = 100\nelement[1] = 101\nelement[2] = 102\nelement[3] = 103\nelement[4] = 104\nelement[5] = 105\nelement[6] = 106\nelement[7] = 107\nelement[8] = 108\nelement[9] = 109\n\narrays in detail\narrays are important to c and should need a lot more attention. the following\nimportant concepts related to array should be clear to a c programmer:\nconcept\n\ndescription\n\nmultidimensional arrays\n\nc supports multidimensional arrays. the\nsimplest form of the multidimensional array is\nthe two-dimensional array.'
p291
aS"\n\npassing arrays to functions\n\nyou can pass to the function a pointer to an\n91\n\nc programming\n\narray by specifying the array's name without an\nindex."
p292
aS'\nreturn array from a function\n\nc allows a function to return an array.'
p293
aS'\n\npointer to an array\n\nyou can generate a pointer to the first element\nof an array by simply specifying the array\nname, without any index.'
p294
aS"\n\nmultidimensional arrays\nc programming language allows multidimensional arrays. here is the general\nform of a multidimensional array declaration:\ntype name[size1][size2]...[sizen];\nfor example, the following declaration creates a three-dimensional integer\narray:\nint threedim[5][10][4];\n\ntwo-dimensional arrays\nthe simplest form of multidimensional array is the two-dimensional array. a\ntwo-dimensional array is, in essence, a list of one-dimensional arrays. to declare\na two-dimensional integer array of size [x][y], you would write something as\nfollows:\ntype arrayname [ x ][ y ];\nwhere type can be any valid c data type and arrayname will be a valid c\nidentifier. a two-dimensional array can be considered as a table which will have\nx number of rows and y number of columns. a two-dimensional array a, which\ncontains three rows and four columns can be shown as follows:\n\nthus, every element in the array a is identified by an element name of the\nform a[ i ][ j ], where \xe2\x80\x98a\xe2\x80\x99 is the name of the array, and \xe2\x80\x98i' and \xe2\x80\x98j\xe2\x80\x99 are the\nsubscripts that uniquely identify each element in \xe2\x80\x98a\xe2\x80\x99."
p295
aS'\n92\n\nc programming\n\ninitializing two-dimensional arrays\nmultidimensional arrays may be initialized by specifying bracketed values for\neach row. following is an array with 3 rows and each row has 4 columns.'
p296
aS'\nint a[3][4] = {\n{0, 1, 2, 3} ,\n\n/*\n\ninitializers for row indexed by 0 */\n\n{4, 5, 6, 7} ,\n\n/*\n\ninitializers for row indexed by 1 */\n\n{8, 9, 10, 11}\n\n/*\n\ninitializers for row indexed by 2 */\n\n};\nthe nested braces, which indicate the intended row, are optional. the following\ninitialization is equivalent to the previous example:\nint a[3][4] = {0,1,2,3,4,5,6,7,8,9,10,11};\n\naccessing two-dimensional array elements\nan element in a two-dimensional array is accessed by using the subscripts, i.e.,\nrow index and column index of the array. for example:\nint val = a[2][3];\nthe above statement will take the 4th element from the 3rd row of the array.'
p297
aS'\nyou can verify it in the above figure. let us check the following program where\nwe have used a nested loop to handle a two-dimensional array:\n#include <stdio.h>\n\nint main ()\n{\n/* an array with 5 rows and 2 columns*/\nint a[5][2] = { {0,0}, {1,2}, {2,4}, {3,6},{4,8}};\nint i, j;\n\n/* output each array element\'s value */\nfor ( i = 0; i < 5; i++ )\n{\nfor ( j = 0; j < 2; j++ )\n{\nprintf("a[%d][%d] = %d\\n", i,j, a[i][j] );\n93\n\nc programming\n\n}\n}\nreturn 0;\n}\nwhen the above code is compiled and executed, it produces the following result:\na[0][0]: 0\na[0][1]: 0\na[1][0]: 1\na[1][1]: 2\na[2][0]: 2\na[2][1]: 4\na[3][0]: 3\na[3][1]: 6\na[4][0]: 4\na[4][1]: 8\nas explained above, you can have arrays with any number of dimensions,\nalthough it is likely that most of the arrays you create will be of one or two\ndimensions.'
p298
aS'\n\npassing arrays to functions\nif you want to pass a single-dimension array as an argument in a function, you\nwould have to declare a formal parameter in one of following three ways and all\nthree declaration methods produce similar results because each tells the\ncompiler that an integer pointer is going to be received. similarly, you can pass\nmulti-dimensional arrays as formal parameters.'
p299
aS'\n\nway-1\nformal parameters as a pointer:\nvoid myfunction(int *param)\n{\n.\n.\n.\n}\n94\n\nc programming\n\nway-2\nformal parameters as a sized array:\nvoid myfunction(int param[10])\n{\n.\n.\n.\n}\n\nway-3\nformal parameters as an unsized array:\nvoid myfunction(int param[])\n{\n.\n.\n.\n}\n\nexample\nnow, consider the following function, which takes an array as an argument along\nwith another argument and based on the passed arguments, it returns the\naverage of the numbers passed through the array as follows:\ndouble getaverage(int arr[], int size)\n{\nint\n\ni;\n\ndouble avg;\ndouble sum;\n\nfor (i = 0; i < size; ++i)\n{\nsum += arr[i];\n}\n\n95\n\nc programming\n\navg = sum / size;\n\nreturn avg;\n}\nnow, let us call the above function as follows:\n#include <stdio.h>\n\n/* function declaration */\ndouble getaverage(int arr[], int size);\n\nint main ()\n{\n/* an int array with 5 elements */\nint balance[5] = {1000, 2, 3, 17, 50};\ndouble avg;\n\n/* pass pointer to the array as an argument */\navg = getaverage( balance, 5 ) ;\n\n/* output the returned value */\nprintf( "average value is: %f ", avg );\n\nreturn 0;\n}\nwhen the above code is compiled together and executed, it produces the\nfollowing result:\naverage value is: 214.400000\nas you can see, the length of the array doesn\'t matter as far as the function is\nconcerned because c performs no bounds checking for formal parameters.'
p300
aS"\n\nreturn array from a function\nc programming does not allow to return an entire array as an argument to a\nfunction. however, you can return a pointer to an array by specifying the array's\nname without an index."
p301
aS'\n96\n\nc programming\nif you want to return a single-dimension array from a function, you would have\nto declare a function returning a pointer as in the following example:\nint * myfunction()\n{\n.\n.\n.\n}\nsecond point to remember is that c does not advocate to return the address of a\nlocal variable to outside of the function, so you would have to define the local\nvariable as static variable.'
p302
aS'\nnow, consider the following function which will generate 10 random numbers\nand return them using an array and call this function as follows:\n#include <stdio.h>\n\n/* function to generate and return random numbers */\nint * getrandom( )\n{\nstatic int\n\nr[10];\n\nint i;\n\n/* set the seed */\nsrand( (unsigned)time( null ) );\nfor ( i = 0; i < 10; ++i)\n{\nr[i] = rand();\nprintf( "r[%d] = %d\\n", i, r[i]);\n\n}\n\nreturn r;\n}\n\n/* main function to call above defined function */\n97\n\nc programming\n\nint main ()\n{\n/* a pointer to an int */\nint *p;\nint i;\n\np = getrandom();\nfor ( i = 0; i < 10; i++ )\n{\nprintf( "*(p + %d) : %d\\n", i, *(p + i));\n}\n\nreturn 0;\n}\nwhen the above code is compiled together and executed, it produces the\nfollowing result:\nr[0] = 313959809\nr[1] = 1759055877\nr[2] = 1113101911\nr[3] = 2133832223\nr[4] = 2073354073\nr[5] = 167288147\nr[6] = 1827471542\nr[7] = 834791014\nr[8] = 1901409888\nr[9] = 1990469526\n*(p + 0) : 313959809\n*(p + 1) : 1759055877\n*(p + 2) : 1113101911\n*(p + 3) : 2133832223\n*(p + 4) : 2073354073\n*(p + 5) : 167288147\n*(p + 6) : 1827471542\n98\n\nc programming\n\n*(p + 7) : 834791014\n*(p + 8) : 1901409888\n*(p + 9) : 1990469526\n\npointer to an array\nit is most likely that you would not understand this section until you are through\nwith the chapter \xe2\x80\x98pointers\xe2\x80\x99.'
p303
aS'\nassuming you have some understanding of pointers in c, let us start: an array\nname is a constant pointer to the first element of the array. therefore, in the\ndeclaration:\ndouble balance[50];\nbalance is a pointer to &balance[0], which is the address of the first element of\nthe array balance. thus, the following program fragment assigns p as the\naddress of the first element of balance:\ndouble *p;\ndouble balance[10];\n\np = balance;\nit is legal to use array names as constant pointers, and vice versa. therefore,\n*(balance + 4) is a legitimate way of accessing the data at balance[4].'
p304
aS'\nonce you store the address of the first element in \xe2\x80\x98p\xe2\x80\x99, you can access the array\nelements using *p, *(p+1), *(p+2), and so on. given below is the example to\nshow all the concepts discussed above:\n#include <stdio.h>\n\nint main ()\n{\n/* an array with 5 elements */\ndouble balance[5] = {1000.0, 2.0, 3.4, 17.0, 50.0};\ndouble *p;\nint i;\n\np = balance;\n\n99\n\nc programming\n\n/* output each array element\'s value */\nprintf( "array values using pointer\\n");\nfor ( i = 0; i < 5; i++ )\n{\nprintf("*(p + %d) : %f\\n",\n\ni, *(p + i) );\n\n}\n\nprintf( "array values using balance as address\\n");\nfor ( i = 0; i < 5; i++ )\n{\nprintf("*(balance + %d) : %f\\n",\n\ni, *(balance + i) );\n\n}\n\nreturn 0;\n}\nwhen the above code is compiled and executed, it produces the following result:\narray values using pointer\n*(p + 0) : 1000.000000\n*(p + 1) : 2.000000\n*(p + 2) : 3.400000\n*(p + 3) : 17.000000\n*(p + 4) : 50.000000\narray values using balance as address\n*(balance + 0) : 1000.000000\n*(balance + 1) : 2.000000\n*(balance + 2) : 3.400000\n*(balance + 3) : 17.000000\n*(balance + 4) : 50.000000\nin the above example, p is a pointer to double, which means it can store the\naddress of a variable of double type. once we have the address in p, *p will give\nus the value available at the address stored in p, as we have shown in the above\nexample.'
p305
aS"\n\n100\n\n15. pointers\n\nc programming\n\npointers in c are easy and fun to learn. some c programming tasks are\nperformed more easily with pointers, and other tasks, such as dynamic memory\nallocation, cannot be performed without using pointers. so it becomes necessary\nto learn pointers to become a perfect c programmer. let's start learning them in\nsimple and easy steps."
p306
aS'\nas you know, every variable is a memory location and every memory location\nhas its address defined which can be accessed using ampersand (&) operator,\nwhich denotes an address in memory. consider the following example, which\nprints the address of the variables defined:\n#include <stdio.h>\n\nint main ()\n{\nint\n\nvar1;\n\nchar var2[10];\n\nprintf("address of var1 variable: %x\\n", &var1\n\n);\n\nprintf("address of var2 variable: %x\\n", &var2\n\n);\n\nreturn 0;\n}\nwhen the above code is compiled and executed, it produces the following result:\naddress of var1 variable: bff5a400\naddress of var2 variable: bff5a3f6\n\nwhat are pointers?\na pointer is a variable whose value is the address of another variable, i.e.,\ndirect address of the memory location. like any variable or constant, you must\ndeclare a pointer before using it to store any variable address. the general form\nof a pointer variable declaration is:\n101\n\nc programming\n\ntype *var-name;\nhere, type is the pointer\'s base type; it must be a valid c data type and varname is the name of the pointer variable. the asterisk * used to declare a\npointer is the same asterisk used for multiplication. however, in this statement,\nthe asterisk is being used to designate a variable as a pointer. take a look at\nsome of the valid pointer declarations:\nint\n\n*ip;\n\n/* pointer to an integer */\n\ndouble *dp;\n\n/* pointer to a double */\n\nfloat\n\n*fp;\n\n/* pointer to a float */\n\nchar\n\n*ch\n\n/* pointer to a character */\n\nthe actual data type of the value of all pointers, whether integer, float,\ncharacter, or otherwise, is the same, a long hexadecimal number that represents\na memory address. the only difference between pointers of different data types\nis the data type of the variable or constant that the pointer points to.'
p307
aS'\n\nhow to use pointers?\nthere are a few important operations, which we will do with the help of pointers\nvery frequently. (a) we define a pointer variable, (b) assign the address of a\nvariable to a pointer, and (c) finally access the value at the address available in\nthe pointer variable. this is done by using unary operator * that returns the\nvalue of the variable located at the address specified by its operand. the\nfollowing example makes use of these operations:\n#include <stdio.h>\n\nint main ()\n{\nint\n\nvar = 20;\n\n/* actual variable declaration */\n\nint\n\n*ip;\n\n/* pointer variable declaration */\n\nip = &var;\n\n/* store address of var in pointer variable*/\n\nprintf("address of var variable: %x\\n", &var\n\n);\n\n/* address stored in pointer variable */\nprintf("address stored in ip variable: %x\\n", ip );\n\n102\n\nc programming\n\n/* access the value using the pointer */\nprintf("value of *ip variable: %d\\n", *ip );\n\nreturn 0;\n}\nwhen the above code is compiled and executed, it produces the following result:\naddress of var variable: bffd8b3c\naddress stored in ip variable: bffd8b3c\nvalue of *ip variable: 20\n\nnull pointers\nit is always a good practice to assign a null value to a pointer variable in case\nyou do not have an exact address to be assigned. this is done at the time of\nvariable declaration. a pointer that is assigned null is called a null pointer.'
p308
aS'\nthe null pointer is a constant with a value of zero defined in several standard\nlibraries. consider the following program:\n#include <stdio.h>\n\nint main ()\n{\nint\n\n*ptr = null;\n\nprintf("the value of ptr is : %x\\n", ptr\n\n);\n\nreturn 0;\n}\nwhen the above code is compiled and executed, it produces the following result:\nthe value of ptr is 0\nin most of the operating systems, programs are not permitted to access\nmemory at address 0 because that memory is reserved by the operating system.'
p309
aS'\nhowever, the memory address 0 has special significance; it signals that the\npointer is not intended to point to an accessible memory location. but by\n103\n\nc programming\nconvention, if a pointer contains the null (zero) value, it is assumed to point to\nnothing.'
p310
aS'\nto check for a null pointer, you can use an \xe2\x80\x98if\xe2\x80\x99 statement as follows:\nif(ptr)\n\n/* succeeds if p is not null */\n\nif(!ptr)\n\n/* succeeds if p is null */\n\npointers in detail\npointers have many but easy concepts and they are very important to c\nprogramming. the following important pointer concepts should be clear to any c\nprogrammer:\nconcept\n\ndescription\n\npointer arithmetic\n\nthere are four arithmetic operators that\ncan be used in pointers: ++, --, +, -\n\narray of pointers\n\nyou can define arrays to hold a number of\npointers.'
p311
aS'\n\npointer to pointer\n\nc allows you to have pointer on a pointer\nand so on.'
p312
aS'\n\npassing pointers to functions in c\n\npassing an argument by reference or by\naddress enable the passed argument to be\nchanged in the calling function by the\ncalled function.'
p313
aS'\n\nreturn pointer from functions in c\n\nc allows a function to return a pointer to\nthe local variable, static variable, and\ndynamically allocated memory as well.'
p314
aS'\n\npointer arithmetic\na pointer in c is an address, which is a numeric value. therefore, you can\nperform arithmetic operations on a pointer just as you can on a numeric value.'
p315
aS'\nthere are four arithmetic operators that can be used on pointers: ++, --, +, and\n-\n\n104\n\nc programming\nto understand pointer arithmetic, let us consider that ptr is an integer pointer\nwhich points to the address 1000. assuming 32-bit integers, let us perform the\nfollowing arithmetic operation on the pointer:\nptr++\nafter the above operation, the ptr will point to the location 1004 because each\ntime ptr is incremented, it will point to the next integer location which is 4 bytes\nnext to the current location. this operation will move the pointer to the next\nmemory location without impacting the actual value at the memory location.'
p316
aS'\nif ptr points to a character whose address is 1000, then the above operation will\npoint to the location 1001 because the next character will be available at 1001.'
p317
aS'\n\nincrementing a pointer\nwe prefer using a pointer in our program instead of an array because the\nvariable pointer can be incremented, unlike the array name which cannot be\nincremented because it is a constant pointer. the following program increments\nthe variable pointer to access each succeeding element of the array:\n#include <stdio.h>\n\nconst int max = 3;\n\nint main ()\n{\nint\n\nvar[] = {10, 100, 200};\n\nint\n\ni, *ptr;\n\n/* let us have array address in pointer */\nptr = var;\nfor ( i = 0; i < max; i++)\n{\n\nprintf("address of var[%d] = %x\\n", i, ptr );\nprintf("value of var[%d] = %d\\n", i, *ptr );\n\n/* move to the next location */\nptr++;\n}\n105\n\nc programming\n\nreturn 0;\n}\nwhen the above code is compiled and executed, it produces the following result:\naddress of var[0] = bf882b30\nvalue of var[0] = 10\naddress of var[1] = bf882b34\nvalue of var[1] = 100\naddress of var[2] = bf882b38\nvalue of var[2] = 200\n\ndecrementing a pointer\nthe same considerations apply to decrementing a pointer, which decreases its\nvalue by the number of bytes of its data type as shown below:\n#include <stdio.h>\n\nconst int max = 3;\n\nint main ()\n{\nint\n\nvar[] = {10, 100, 200};\n\nint\n\ni, *ptr;\n\n/* let us have array address in pointer */\nptr = &var[max-1];\nfor ( i = max; i > 0; i--)\n{\n\nprintf("address of var[%d] = %x\\n", i, ptr );\nprintf("value of var[%d] = %d\\n", i, *ptr );\n\n/* move to the previous location */\nptr--;\n\n106\n\nc programming\n\n}\nreturn 0;\n}\nwhen the above code is compiled and executed, it produces the following result:\naddress of var[3] = bfedbcd8\nvalue of var[3] = 200\naddress of var[2] = bfedbcd4\nvalue of var[2] = 100\naddress of var[1] = bfedbcd0\nvalue of var[1] = 10\n\npointer comparisons\npointers may be compared by using relational operators, such as ==, <, and >.'
p318
aS'\nif p1 and p2 point to variables that are related to each other, such as elements\nof the same array, then p1 and p2 can be meaningfully compared.'
p319
aS'\nthe following program modifies the previous example - one by incrementing the\nvariable pointer so long as the address to which it points is either less than or\nequal to the address of the last element of the array, which is &var[max - 1]:\n#include <stdio.h>\n\nconst int max = 3;\n\nint main ()\n{\nint\n\nvar[] = {10, 100, 200};\n\nint\n\ni, *ptr;\n\n/* let us have address of the first element in pointer */\nptr = var;\ni = 0;\nwhile ( ptr <= &var[max - 1] )\n{\n\n107\n\nc programming\n\nprintf("address of var[%d] = %x\\n", i, ptr );\nprintf("value of var[%d] = %d\\n", i, *ptr );\n\n/* point to the previous location */\nptr++;\ni++;\n}\nreturn 0;\n}\nwhen the above code is compiled and executed, it produces the following result:\naddress of var[0] = bfdbcb20\nvalue of var[0] = 10\naddress of var[1] = bfdbcb24\nvalue of var[1] = 100\naddress of var[2] = bfdbcb28\nvalue of var[2] = 200\n\narray of pointers\nbefore we understand the concept of arrays of pointers, let us consider the\nfollowing example, which uses an array of 3 integers:\n#include <stdio.h>\n\nconst int max = 3;\n\nint main ()\n{\nint\n\nvar[] = {10, 100, 200};\n\nint i;\n\nfor (i = 0; i < max; i++)\n{\nprintf("value of var[%d] = %d\\n", i, var[i] );\n\n108\n\nc programming\n\n}\nreturn 0;\n}\nwhen the above code is compiled and executed, it produces the following result:\nvalue of var[0] = 10\nvalue of var[1] = 100\nvalue of var[2] = 200\nthere may be a situation when we want to maintain an array, which can store\npointers to an int or char or any other data type available. following is the\ndeclaration of an array of pointers to an integer:\nint *ptr[max];\nit declares ptr as an array of max integer pointers. thus, each element in ptr\nholds a pointer to an int value. the following example uses three integers, which\nare stored in an array of pointers, as follows:\n#include <stdio.h>\n\nconst int max = 3;\n\nint main ()\n{\nint\n\nvar[] = {10, 100, 200};\n\nint i, *ptr[max];\n\nfor ( i = 0; i < max; i++)\n{\nptr[i] = &var[i]; /* assign the address of integer. */\n}\nfor ( i = 0; i < max; i++)\n{\nprintf("value of var[%d] = %d\\n", i, *ptr[i] );\n}\nreturn 0;\n\n109\n\nc programming\n\n}\nwhen the above code is compiled and executed, it produces the following result:\nvalue of var[0] = 10\nvalue of var[1] = 100\nvalue of var[2] = 200\nyou can also use an array of pointers to character to store a list of strings as\nfollows:\n#include <stdio.h>\n\nconst int max = 4;\n\nint main ()\n{\nchar *names[] = {\n"zara ali",\n"hina ali",\n"nuha ali",\n"sara ali",\n};\nint i = 0;\n\nfor ( i = 0; i < max; i++)\n{\nprintf("value of names[%d] = %s\\n", i, names[i] );\n}\nreturn 0;\n}\nwhen the above code is compiled and executed, it produces the following result:\nvalue of names[0] = zara ali\nvalue of names[1] = hina ali\nvalue of names[2] = nuha ali\nvalue of names[3] = sara ali\n110\n\nc programming\n\npointer to pointer\na pointer to a pointer is a form of multiple indirection, or a chain of pointers.'
p320
aS'\nnormally, a pointer contains the address of a variable. when we define a pointer\nto a pointer, the first pointer contains the address of the second pointer, which\npoints to the location that contains the actual value as shown below.'
p321
aS'\n\na variable that is a pointer to a pointer must be declared as such. this is done\nby placing an additional asterisk in front of its name. for example, the following\ndeclaration declares a pointer to a pointer of type int:\nint **var;\nwhen a target value is indirectly pointed to by a pointer to a pointer, accessing\nthat value requires that the asterisk operator be applied twice, as is shown\nbelow in the example:\n#include <stdio.h>\n\nint main ()\n{\nint\n\nvar;\n\nint\n\n*ptr;\n\nint\n\n**pptr;\n\nvar = 3000;\n\n/* take the address of var */\nptr = &var;\n\n/* take the address of ptr using address of operator & */\npptr = &ptr;\n\n/* take the value using pptr */\nprintf("value of var = %d\\n", var );\nprintf("value available at *ptr = %d\\n", *ptr );\nprintf("value available at **pptr = %d\\n", **pptr);\n111\n\nc programming\n\nreturn 0;\n}\nwhen the above code is compiled and executed, it produces the following result:\nvalue of var = 3000\nvalue available at *ptr = 3000\nvalue available at **pptr = 3000\n\npassing pointers to functions\nc programming allows passing a pointer to a function. to do so, simply declare\nthe function parameter as a pointer type.'
p322
aS'\nfollowing is a simple example where we pass an unsigned long pointer to a\nfunction and change the value inside the function which reflects back in the\ncalling function:\n#include <stdio.h>\n#include <time.h>\n\nvoid getseconds(unsigned long *par);\n\nint main ()\n{\nunsigned long sec;\n\ngetseconds( &sec );\n\n/* print the actual value */\nprintf("number of seconds: %ld\\n", sec );\n\nreturn 0;\n}\n\nvoid getseconds(unsigned long *par)\n\n112\n\nc programming\n\n{\n/* get the current number of seconds */\n*par = time( null );\nreturn;\n}\nwhen the above code is compiled and executed, it produces the following result:\nnumber of seconds :1294450468\nthe function, which can accept a pointer, can also accept an array as shown in\nthe following example:\n#include <stdio.h>\n\n/* function declaration */\ndouble getaverage(int *arr, int size);\n\nint main ()\n{\n/* an int array with 5 elements */\nint balance[5] = {1000, 2, 3, 17, 50};\ndouble avg;\n\n/* pass pointer to the array as an argument */\navg = getaverage( balance, 5 ) ;\n\n/* output the returned value\n\n*/\n\nprintf("average value is: %f\\n", avg );\n\nreturn 0;\n}\n\ndouble getaverage(int *arr, int size)\n{\nint\n\ni, sum = 0;\n\ndouble avg;\n113\n\nc programming\n\nfor (i = 0; i < size; ++i)\n{\nsum += arr[i];\n}\n\navg = (double)sum / size;\n\nreturn avg;\n}\nwhen the above code is compiled together and executed, it produces the\nfollowing result:\naverage value is: 214.40000\n\nreturn pointer from functions\nwe have seen in the last chapter how c programming allows to return an array\nfrom a function. similarly, c also allows to return a pointer from a function. to\ndo so, you would have to declare a function returning a pointer as in the\nfollowing example:\nint * myfunction()\n{\n.\n.\n.\n}\nsecond point to remember is that, it is not a good idea to return the address of\na local variable outside the function, so you would have to define the local\nvariable as static variable.'
p323
aS'\nnow, consider the following function which will generate 10 random numbers\nand return them using an array name which represents a pointer, i.e., address\nof first array element.'
p324
aS'\n#include <stdio.h>\n#include <time.h>\n\n114\n\nc programming\n\n/* function to generate and retrun random numbers. */\nint * getrandom( )\n{\nstatic int\n\nr[10];\n\nint i;\n\n/* set the seed */\nsrand( (unsigned)time( null ) );\nfor ( i = 0; i < 10; ++i)\n{\nr[i] = rand();\nprintf("%d\\n", r[i] );\n}\n\nreturn r;\n}\n\n/* main function to call above defined function */\nint main ()\n{\n/* a pointer to an int */\nint *p;\nint i;\n\np = getrandom();\nfor ( i = 0; i < 10; i++ )\n{\nprintf("*(p + [%d]) : %d\\n", i, *(p + i) );\n}\n\nreturn 0;\n}\nwhen the above code is compiled together and executed, it produces the\nfollowing result:\n115\n\nc programming\n\n1523198053\n1187214107\n1108300978\n430494959\n1421301276\n930971084\n123250484\n106932140\n1604461820\n149169022\n*(p + [0]) : 1523198053\n*(p + [1]) : 1187214107\n*(p + [2]) : 1108300978\n*(p + [3]) : 430494959\n*(p + [4]) : 1421301276\n*(p + [5]) : 930971084\n*(p + [6]) : 123250484\n*(p + [7]) : 106932140\n*(p + [8]) : 1604461820\n*(p + [9]) : 149169022\n\n116\n\n16. strings\n\nc programming\n\nstrings are actually one-dimensional array of characters terminated by\na null character \'\\0\'. thus a null-terminated string contains the characters that\ncomprise the string followed by a null.'
p325
aS'\nthe following declaration and initialization create a string consisting of the word\n"hello". to hold the null character at the end of the array, the size of the\ncharacter array containing the string is one more than the number of characters\nin the word "hello."\nchar greeting[6] = {\'h\', \'e\', \'l\', \'l\', \'o\', \'\\0\'};\nif you follow the rule of array initialization, then you can write the above\nstatement as follows:\nchar greeting[] = "hello";\nfollowing is the memory presentation of the above defined string in c/c++:\n\nactually, you do not place the null character at the end of a string constant. the\nc compiler automatically places the \'\\0\' at the end of the string when it initializes\nthe array. let us try to print the above mentioned string:\n#include <stdio.h>\n\nint main ()\n{\nchar greeting[6] = {\'h\', \'e\', \'l\', \'l\', \'o\', \'\\0\'};\n\nprintf("greeting message: %s\\n", greeting );\n\n117\n\nc programming\n\nreturn 0;\n}\nwhen the above code is compiled and executed, it produces the following result:\ngreeting message: hello\n\nc supports a wide range of functions that manipulate null-terminated strings:\ns.n.'
p326
aS'\n1\n\nfunction & purpose\nstrcpy(s1, s2);\ncopies string s2 into string s1.'
p327
aS'\n\n2\n\nstrcat(s1, s2);\nconcatenates string s2 onto the end of string s1.'
p328
aS'\n\n3\n\nstrlen(s1);\nreturns the length of string s1.'
p329
aS'\n\n4\n\nstrcmp(s1, s2);\nreturns 0 if s1 and s2 are the same; less than 0 if s1<s2; greater than\n0 if s1>s2.'
p330
aS'\n\n5\n\nstrchr(s1, ch);\nreturns a pointer to the first occurrence of character ch in string s1.'
p331
aS'\n\n6\n\nstrstr(s1, s2);\nreturns a pointer to the first occurrence of string s2 in string s1.'
p332
aS'\n\nthe following example uses some of the above-mentioned functions:\n#include <stdio.h>\n#include <string.h>\n118\n\nc programming\n\nint main ()\n{\nchar str1[12] = "hello";\nchar str2[12] = "world";\nchar str3[12];\nint\n\nlen ;\n\n/* copy str1 into str3 */\nstrcpy(str3, str1);\nprintf("strcpy( str3, str1) :\n\n%s\\n", str3 );\n\n/* concatenates str1 and str2 */\nstrcat( str1, str2);\nprintf("strcat( str1, str2):\n\n%s\\n", str1 );\n\n/* total lenghth of str1 after concatenation */\nlen = strlen(str1);\nprintf("strlen(str1) :\n\n%d\\n", len );\n\nreturn 0;\n}\nwhen the above code is compiled and executed, it produces the following result:\nstrcpy( str3, str1) :\n\nhello\n\nstrcat( str1, str2):\n\nhelloworld\n\nstrlen(str1) :\n\n10\n\n119\n\n17. structures\n\nc programming\n\narrays allow to define type of variables that can hold several data items of the\nsame kind. similarly, structure is another user-defined data type available in c\nthat allows to combine data items of different kinds.'
p333
aS'\nstructures are used to represent a record. suppose you want to keep track of\nyour books in a library. you might want to track the following attributes about\neach book:\n\xef\x82\xb7\n\ntitle\n\n\xef\x82\xb7\n\nauthor\n\n\xef\x82\xb7\n\nsubject\n\n\xef\x82\xb7\n\nbook id\n\ndefining a structure\nto define a structure, you must use the struct statement. the struct statement\ndefines a new data type, with more than one member. the format of the struct\nstatement is as follows:\nstruct [structure tag]\n{\nmember definition;\nmember definition;\n...'
p334
aS'\nmember definition;\n} [one or more structure variables];\nthe structure tag is optional and each member definition is a normal variable\ndefinition, such as int i; or float f; or any other valid variable definition. at the\nend of the structure\'s definition, before the final semicolon, you can specify one\nor more structure variables but it is optional. here is the way you would declare\nthe book structure:\nstruct books\n{\nchar\n\ntitle[50];\n\nchar\n\nauthor[50];\n120\n\nc programming\n\nchar\n\nsubject[100];\n\nint\n\nbook_id;\n\n} book;\n\naccessing structure members\nto access any member of a structure, we use the member access operator\n(.). the member access operator is coded as a period between the structure\nvariable name and the structure member that we wish to access. you would\nuse the keyword struct to define variables of structure type. the following\nexample shows how to use a structure in a program:\n#include <stdio.h>\n#include <string.h>\n\nstruct books\n{\nchar\n\ntitle[50];\n\nchar\n\nauthor[50];\n\nchar\n\nsubject[100];\n\nint\n\nbook_id;\n\n};\n\nint main( )\n{\nstruct books book1;\n\n/* declare book1 of type book */\n\nstruct books book2;\n\n/* declare book2 of type book */\n\n/* book 1 specification */\nstrcpy( book1.title, "c programming");\nstrcpy( book1.author, "nuha ali");\nstrcpy( book1.subject, "c programming tutorial");\nbook1.book_id = 6495407;\n\n/* book 2 specification */\nstrcpy( book2.title, "telecom billing");\n121\n\nc programming\n\nstrcpy( book2.author, "zara ali");\nstrcpy( book2.subject, "telecom billing tutorial");\nbook2.book_id = 6495700;\n\n/* print book1 info */\nprintf( "book 1 title : %s\\n", book1.title);\nprintf( "book 1 author : %s\\n", book1.author);\nprintf( "book 1 subject : %s\\n", book1.subject);\nprintf( "book 1 book_id : %d\\n", book1.book_id);\n\n/* print book2 info */\nprintf( "book 2 title : %s\\n", book2.title);\nprintf( "book 2 author : %s\\n", book2.author);\nprintf( "book 2 subject : %s\\n", book2.subject);\nprintf( "book 2 book_id : %d\\n", book2.book_id);\n\nreturn 0;\n}\nwhen the above code is compiled and executed, it produces the following result:\nbook 1 title : c programming\nbook 1 author : nuha ali\nbook 1 subject : c programming tutorial\nbook 1 book_id : 6495407\nbook 2 title : telecom billing\nbook 2 author : zara ali\nbook 2 subject : telecom billing tutorial\nbook 2 book_id : 6495700\n\nstructures as function arguments\nyou can pass a structure as a function argument in the same way as you pass\nany other variable or pointer.'
p335
aS'\n\n#include <stdio.h>\n122\n\nc programming\n\n#include <string.h>\n\nstruct books\n{\nchar\n\ntitle[50];\n\nchar\n\nauthor[50];\n\nchar\n\nsubject[100];\n\nint\n\nbook_id;\n\n};\n\n/* function declaration */\nvoid printbook( struct books book );\nint main( )\n{\nstruct books book1;\n\n/* declare book1 of type book */\n\nstruct books book2;\n\n/* declare book2 of type book */\n\n/* book 1 specification */\nstrcpy( book1.title, "c programming");\nstrcpy( book1.author, "nuha ali");\nstrcpy( book1.subject, "c programming tutorial");\nbook1.book_id = 6495407;\n\n/* book 2 specification */\nstrcpy( book2.title, "telecom billing");\nstrcpy( book2.author, "zara ali");\nstrcpy( book2.subject, "telecom billing tutorial");\nbook2.book_id = 6495700;\n\n/* print book1 info */\nprintbook( book1 );\n\n/* print book2 info */\n\n123\n\nc programming\n\nprintbook( book2 );\n\nreturn 0;\n}\nvoid printbook( struct books book )\n{\nprintf( "book title : %s\\n", book.title);\nprintf( "book author : %s\\n", book.author);\nprintf( "book subject : %s\\n", book.subject);\nprintf( "book book_id : %d\\n", book.book_id);\n}\nwhen the above code is compiled and executed, it produces the following result:\nbook title : c programming\nbook author : nuha ali\nbook subject : c programming tutorial\nbook book_id : 6495407\nbook title : telecom billing\nbook author : zara ali\nbook subject : telecom billing tutorial\nbook book_id : 6495700\n\npointers to structures\nyou can define pointers to structures in the same way as you define pointer to\nany other variable:\nstruct books *struct_pointer;\nnow, you can store the address of a structure variable in the above-defined\npointer variable. to find the address of a structure variable, place the \xe2\x80\x98&\xe2\x80\x99\noperator before the structure\'s name as follows:\nstruct_pointer = &book1;\nto access the members of a structure using a pointer to that structure, you must\nuse the -> operator as follows:\nstruct_pointer->title;\n124\n\nc programming\nlet us rewrite the above example using structure pointer.'
p336
aS'\n#include <stdio.h>\n#include <string.h>\n\nstruct books\n{\nchar\n\ntitle[50];\n\nchar\n\nauthor[50];\n\nchar\n\nsubject[100];\n\nint\n\nbook_id;\n\n};\n\n/* function declaration */\nvoid printbook( struct books *book );\nint main( )\n{\nstruct books book1;\n\n/* declare book1 of type book */\n\nstruct books book2;\n\n/* declare book2 of type book */\n\n/* book 1 specification */\nstrcpy( book1.title, "c programming");\nstrcpy( book1.author, "nuha ali");\nstrcpy( book1.subject, "c programming tutorial");\nbook1.book_id = 6495407;\n\n/* book 2 specification */\nstrcpy( book2.title, "telecom billing");\nstrcpy( book2.author, "zara ali");\nstrcpy( book2.subject, "telecom billing tutorial");\nbook2.book_id = 6495700;\n\n/* print book1 info by passing address of book1 */\nprintbook( &book1 );\n\n125\n\nc programming\n\n/* print book2 info by passing address of book2 */\nprintbook( &book2 );\n\nreturn 0;\n}\nvoid printbook( struct books *book )\n{\nprintf( "book title : %s\\n", book->title);\nprintf( "book author : %s\\n", book->author);\nprintf( "book subject : %s\\n", book->subject);\nprintf( "book book_id : %d\\n", book->book_id);\n}\nwhen the above code is compiled and executed, it produces the following result:\nbook title : c programming\nbook author : nuha ali\nbook subject : c programming tutorial\nbook book_id : 6495407\nbook title : telecom billing\nbook author : zara ali\nbook subject : telecom billing tutorial\nbook book_id : 6495700\n\nbit fields\nbit fields allow the packing of data in a structure. this is especially useful when\nmemory or data storage is at a premium. typical examples include:\n\xef\x82\xb7\n\npacking several objects into a machine word, e.g. 1 bit flags can be\ncompacted.'
p337
aS'\n\n\xef\x82\xb7\n\nreading external file formats -- non-standard file formats could be read\nin, e.g., 9-bit integers.'
p338
aS'\n\nc allows us to do this in a structure definition by putting :bit length after the\nvariable. for example:\nstruct packed_struct {\n\n126\n\nc programming\n\nunsigned int f1:1;\nunsigned int f2:1;\nunsigned int f3:1;\nunsigned int f4:1;\nunsigned int type:4;\nunsigned int my_int:9;\n} pack;\nhere, the packed_struct contains 6 members: four 1 bit flags f1..f3, a 4-bit\ntype, and a 9-bit my_int.'
p339
aS'\nc automatically packs the above bit fields as compactly as possible, provided\nthat the maximum length of the field is less than or equal to the integer word\nlength of the computer. if this is not the case, then some compilers may allow\nmemory overlap for the fields, while others would store the next field in the next\nword.'
p340
aS'\n\n127\n\n18. unions\n\nc programming\n\na union is a special data type available in c that allows to store different data\ntypes in the same memory location. you can define a union with many\nmembers, but only one member can contain a value at any given time. unions\nprovide an efficient way of using the same memory location for multiple\npurpose.'
p341
aS'\n\ndefining a union\nto define a union, you must use the union statement in the same way as you\ndid while defining a structure. the union statement defines a new data type with\nmore than one member for your program. the format of the union statement is\nas follows:\nunion [union tag]\n{\nmember definition;\nmember definition;\n...'
p342
aS"\nmember definition;\n} [one or more union variables];\nthe union tag is optional and each member definition is a normal variable\ndefinition, such as int i; or float f; or any other valid variable definition. at the\nend of the union's definition, before the final semicolon, you can specify one or\nmore union variables, but it is optional. here is the way you would define a\nunion type named data having three members i, f, and str:\nunion data\n{\nint i;\nfloat f;\nchar\n\nstr[20];\n\n} data;\nnow, a variable of data type can store an integer, a floating-point number, or a\nstring of characters. it means a single variable, i.e., same memory location, can\n\n128\n\nc programming\nbe used to store multiple types of data. you can use any built-in or user-defined\ndata types inside a union based on your requirement."
p343
aS'\nthe memory occupied by a union will be large enough to hold the largest\nmember of the union. for example, in the above example, data type will occupy\n20 bytes of memory space because this is the maximum space which can be\noccupied by a character string. the following example displays the total memory\nsize occupied by the above union:\n#include <stdio.h>\n#include <string.h>\n\nunion data\n{\nint i;\nfloat f;\nchar\n\nstr[20];\n\n};\n\nint main( )\n{\nunion data data;\n\nprintf( "memory size occupied by data : %d\\n", sizeof(data));\n\nreturn 0;\n}\nwhen the above code is compiled and executed, it produces the following result:\nmemory size occupied by data : 20\n\naccessing union members\nto access any member of a union, we use the member access operator (.).'
p344
aS'\nthe member access operator is coded as a period between the union variable\nname and the union member that we wish to access. you would use the keyword\nunion to define variables of union type. the following example shows how to\nuse unions in a program:\n#include <stdio.h>\n129\n\nc programming\n\n#include <string.h>\n\nunion data\n{\nint i;\nfloat f;\nchar\n\nstr[20];\n\n};\n\nint main( )\n{\nunion data data;\n\ndata.i = 10;\ndata.f = 220.5;\nstrcpy( data.str, "c programming");\n\nprintf( "data.i : %d\\n", data.i);\nprintf( "data.f : %f\\n", data.f);\nprintf( "data.str : %s\\n", data.str);\n\nreturn 0;\n}\nwhen the above code is compiled and executed, it produces the following result:\ndata.i : 1917853763\ndata.f : 4122360580327794860452759994368.000000\ndata.str : c programming\nhere, we can see that the values of i and f members of union got corrupted\nbecause the final value assigned to the variable has occupied the memory\nlocation and this is the reason that the value of str member is getting printed\nvery well.'
p345
aS'\nnow let\'s look into the same example once again where we will use one variable\nat a time which is the main purpose of having unions:\n#include <stdio.h>\n130\n\nc programming\n\n#include <string.h>\n\nunion data\n{\nint i;\nfloat f;\nchar\n\nstr[20];\n\n};\n\nint main( )\n{\nunion data data;\n\ndata.i = 10;\nprintf( "data.i : %d\\n", data.i);\n\ndata.f = 220.5;\nprintf( "data.f : %f\\n", data.f);\n\nstrcpy( data.str, "c programming");\nprintf( "data.str : %s\\n", data.str);\n\nreturn 0;\n}\nwhen the above code is compiled and executed, it produces the following result:\ndata.i : 10\ndata.f : 220.500000\ndata.str : c programming\nhere, all the members are getting printed very well because one member is\nbeing used at a time.'
p346
aS'\n\n131\n\n19. bit fields\n\nc programming\n\nsuppose your c program contains a number of true/false variables grouped in\na structure called status, as follows:\nstruct\n{\nunsigned int widthvalidated;\nunsigned int heightvalidated;\n} status;\nthis structure requires 8 bytes of memory space but in actual, we are going to\nstore either 0 or 1 in each of the variables. the c programming language offers\na better way to utilize the memory space in such situations.'
p347
aS'\nif you are using such variables inside a structure, then you can define the width\nof a variable which tells the c compiler that you are going to use only those\nnumber of bytes. for example, the above structure can be rewritten as follows:\nstruct\n{\nunsigned int widthvalidated : 1;\nunsigned int heightvalidated : 1;\n} status;\nthe above structure requires 4 bytes of memory space for status variable, but\nonly 2 bits will be used to store the values.'
p348
aS'\nif you will use up to 32 variables, each one with a width of 1 bit, then also the\nstatus structure will use 4 bytes. however, as soon as you have 33 variables, it\nwill allocate the next slot of the memory and it will start using 8 bytes. let us\ncheck the following example to understand the concept:\n#include <stdio.h>\n#include <string.h>\n\n/* define simple structure */\nstruct\n{\n\n132\n\nc programming\n\nunsigned int widthvalidated;\nunsigned int heightvalidated;\n} status1;\n\n/* define a structure with bit fields */\nstruct\n{\nunsigned int widthvalidated : 1;\nunsigned int heightvalidated : 1;\n} status2;\n\nint main( )\n{\nprintf( "memory size occupied by status1 : %d\\n", sizeof(status1));\nprintf( "memory size occupied by status2 : %d\\n", sizeof(status2));\n\nreturn 0;\n}\nwhen the above code is compiled and executed, it produces the following result:\nmemory size occupied by status1 : 8\nmemory size occupied by status2 : 4\n\nbit field declaration\nthe declaration of a bit-field has the following form inside a structure:\nstruct\n{\ntype [member_name] : width ;\n};\nthe following table describes the variable elements of a bit field:\nelements\n\ndescription\n\n133\n\nc programming\n\ntype\n\nan integer type that determines how a bit-field\'s value is\ninterpreted. the type may be int, signed int, or unsigned int.'
p349
aS'\n\nmember_name\n\nthe name of the bit-field.'
p350
aS'\n\nwidth\n\nthe number of bits in the bit-field. the width must be less\nthan or equal to the bit width of the specified type.'
p351
aS'\n\nthe variables defined with a predefined width are called bit fields. a bit field can\nhold more than a single bit; for example, if you need a variable to store a value\nfrom 0 to 7, then you can define a bit-field with a width of 3 bits as follows:\nstruct\n{\nunsigned int age : 3;\n} age;\nthe above structure definition instructs the c compiler that the age variable is\ngoing to use only 3 bits to store the value. if you try to use more than 3 bits,\nthen it will not allow you to do so. let us try the following example:\n#include <stdio.h>\n#include <string.h>\n\nstruct\n{\nunsigned int age : 3;\n} age;\n\nint main( )\n{\nage.age = 4;\nprintf( "sizeof( age ) : %d\\n", sizeof(age) );\nprintf( "age.age : %d\\n", age.age );\n\nage.age = 7;\nprintf( "age.age : %d\\n", age.age );\n134\n\nc programming\n\nage.age = 8;\nprintf( "age.age : %d\\n", age.age );\n\nreturn 0;\n}\nwhen the above code is compiled, it will compile with a warning and when\nexecuted, it produces the following result:\nsizeof( age ) : 4\nage.age : 4\nage.age : 7\nage.age : 0\n\n135\n\n20. typedef\n\nc programming\n\nthe c programming language provides a keyword called typedef, which you can\nuse to give a type, a new name. following is an example to define a\nterm byte for one-byte numbers:\ntypedef unsigned char byte;\nafter this type definition, the identifier byte can be used as an abbreviation for\nthe type unsigned char, for example:\nbyte\n\nb1, b2;\n\nby convention, uppercase letters are used for these definitions to remind the\nuser that the type name is really a symbolic abbreviation, but you can use\nlowercase, as follows:\ntypedef unsigned char byte;\nyou can use typedef to give a name to your user-defined data types as well. for\nexample, you can use typedef with structure to define a new data type and then\nuse that data type to define structure variables directly as follows:\n#include <stdio.h>\n#include <string.h>\n\ntypedef struct books\n{\nchar\n\ntitle[50];\n\nchar\n\nauthor[50];\n\nchar\n\nsubject[100];\n\nint\n\nbook_id;\n\n} book;\n\nint main( )\n{\nbook book;\n\n136\n\nc programming\n\nstrcpy( book.title, "c programming");\nstrcpy( book.author, "nuha ali");\nstrcpy( book.subject, "c programming tutorial");\nbook.book_id = 6495407;\n\nprintf( "book title : %s\\n", book.title);\nprintf( "book author : %s\\n", book.author);\nprintf( "book subject : %s\\n", book.subject);\nprintf( "book book_id : %d\\n", book.book_id);\n\nreturn 0;\n}\nwhen the above code is compiled and executed, it produces the following result:\nbook\n\ntitle : c programming\n\nbook\n\nauthor : nuha ali\n\nbook\n\nsubject : c programming tutorial\n\nbook\n\nbook_id : 6495407\n\ntypedef vs #define\n#define is a c-directive which is also used to define the aliases for various data\ntypes similar to typedef but with the following differences:\n\xef\x82\xb7\n\ntypedef is limited to giving symbolic names to types only,\nwhereas #define can be used to define alias for values as well, e.g., you\ncan define 1 as one, etc.'
p352
aS'\n\n\xef\x82\xb7\n\ntypedef interpretation is performed by the compiler whereas #define\nstatements are processed by the preprocessor.'
p353
aS'\n\nthe following example shows how to use #define in a program:\n#include <stdio.h>\n\n#define true\n\n1\n\n#define false 0\n\nint main( )\n\n137\n\nc programming\n\n{\nprintf( "value of true : %d\\n", true);\nprintf( "value of false : %d\\n", false);\n\nreturn 0;\n}\nwhen the above code is compiled and executed, it produces the following result:\nvalue of true : 1\nvalue of false : 0\n\n138\n\nc programming\n\n21. input and output\n\nwhen we say input, it means to feed some data into a program. an input can be\ngiven in the form of a file or from the command line. c programming provides a\nset of built-in functions to read the given input and feed it to the program as per\nrequirement.'
p354
aS'\nwhen we say output, it means to display some data on screen, printer, or in\nany file. c programming provides a set of built-in functions to output the data on\nthe computer screen as well as to save it in text or binary files.'
p355
aS'\n\nthe standard files\nc programming treats all the devices as files. so devices such as the display are\naddressed in the same way as files and the following three files are\nautomatically opened when a program executes to provide access to the\nkeyboard and screen.'
p356
aS'\nstandard file\n\nfile pointer\n\ndevice\n\nstandard input\n\nstdin\n\nkeyboard\n\nstandard output\n\nstdout\n\nscreen\n\nstandard error\n\nstderr\n\nyour screen\n\nthe file pointers are the means to access the file for reading and writing\npurpose. this section explains how to read values from the screen and how to\nprint the result on the screen.'
p357
aS'\n\nthe getchar() and putchar() functions\nthe int getchar(void) function reads the next available character from the\nscreen and returns it as an integer. this function reads only single character at a\ntime. you can use this method in the loop in case you want to read more than\none character from the screen.'
p358
aS'\nthe int putchar(int c) function puts the passed character on the screen and\nreturns the same character. this function puts only single character at a time.'
p359
aS'\nyou can use this method in the loop in case you want to display more than one\ncharacter on the screen. check the following example:\n139\n\nc programming\n\n#include <stdio.h>\nint main( )\n{\nint c;\n\nprintf( "enter a value :");\nc = getchar( );\n\nprintf( "\\nyou entered: ");\nputchar( c );\n\nreturn 0;\n}\nwhen the above code is compiled and executed, it waits for you to input some\ntext. when you enter a text and press enter, then the program proceeds and\nreads only a single character and displays it as follows:\n$./a.out\nenter a value : this is test\nyou entered: t\n\nthe gets() and puts() functions\nthe char *gets(char *s) function reads a line from stdin into the buffer\npointed to by s until either a terminating newline or eof (end of file).'
p360
aS'\nthe int puts(const char *s) function writes the string \xe2\x80\x98s\xe2\x80\x99 and \xe2\x80\x98a\xe2\x80\x99 trailing\nnewline to stdout.'
p361
aS'\n#include <stdio.h>\nint main( )\n{\nchar str[100];\n\nprintf( "enter a value :");\ngets( str );\n\n140\n\nc programming\n\nprintf( "\\nyou entered: ");\nputs( str );\n\nreturn 0;\n}\nwhen the above code is compiled and executed, it waits for you to input some\ntext. when you enter a text and press enter, then the program proceeds and\nreads the complete line till end, and displays it as follows:\n$./a.out\nenter a value : this is test\nyou entered: this is test\n\nthe scanf() and printf() functions\nthe int scanf(const char *format, ...) function reads the input from the\nstandard input stream stdin and scans that input according to the\nformat provided.'
p362
aS'\nthe int printf(const char *format, ...) function writes the output to the\nstandard output stream stdout and produces the output according to the format\nprovided.'
p363
aS'\nthe format can be a simple constant string, but you can specify %s, %d, %c,\n%f, etc., to print or read strings, integer, character, or float, respectively. there\nare many other formatting options available which can be used based on\nrequirements. let us now proceed with a simple example to understand the\nconcepts better:\n#include <stdio.h>\nint main( )\n{\nchar str[100];\nint i;\n\nprintf( "enter a value :");\nscanf("%s %d", str, &i);\n\nprintf( "\\nyou entered: %s %d ", str, i);\n\n141\n\nc programming\n\nreturn 0;\n}\nwhen the above code is compiled and executed, it waits for you to input some\ntext. when you enter a text and press enter, then program proceeds and reads\nthe input and displays it as follows:\n$./a.out\nenter a value : seven 7\nyou entered: seven 7\nhere, it should be noted that scanf() expects input in the same format as you\nprovided %s and %d, which means you have to provide valid inputs like "string\ninteger". if you provide "string string" or "integer integer", then it will be\nassumed as wrong input. secondly, while reading a string, scanf() stops reading\nas soon as it encounters a space, so "this is test" are three strings for scanf().'
p364
aS'\n\n142\n\n22. file i/o\n\nc programming\n\nthe last chapter explained the standard input and output devices handled by c\nprogramming language. this chapter covers how c programmers can create,\nopen, close text or binary files for their data storage.'
p365
aS'\na file represents a sequence of bytes, regardless of it being a text file or a binary\nfile. c programming language provides access on high-level functions as well as\nlow-level (os level) calls to handle file on your storage devices. this chapter will\ntake you through the important calls for file management.'
p366
aS'\n\nopening files\nyou can use the fopen( ) function to create a new file or to open an existing file.'
p367
aS'\nthis call will initialize an object of the type file, which contains all the\ninformation necessary to control the stream. the prototype of this function call is\nas follows:\nfile *fopen( const char * filename, const char * mode );\nhere, filename is a string literal, which you will use to name your file, and\naccess mode can have one of the following values:\nmode\n\ndescription\n\nr\n\nopens an existing text file for reading purpose.'
p368
aS'\n\nw\n\nopens a text file for writing. if it does not exist, then a new file is\ncreated. here your program will start writing content from the\nbeginning of the file.'
p369
aS'\n\na\n\nopens a text file for writing in appending mode. if it does not exist,\nthen a new file is created. here your program will start appending\ncontent in the existing file content.'
p370
aS'\n\nr+\n\nopens a text file for both reading and writing.'
p371
aS'\n\nw+\n\nopens a text file for both reading and writing. it first truncates the file\nto zero length if it exists, otherwise creates a file if it does not exist.'
p372
aS'\n\n143\n\nc programming\n\na+\n\nopens a text file for both reading and writing. it creates the file if it\ndoes not exist. the reading will start from the beginning but writing\ncan only be appended.'
p373
aS'\n\nif you are going to handle binary files, then you will use the following access\nmodes instead of the above-mentioned ones:\n"rb", "wb", "ab", "rb+", "r+b", "wb+", "w+b", "ab+", "a+b"\n\nclosing a file\nto close a file, use the fclose( ) function. the prototype of this function is:\nint fclose( file *fp );\nthe fclose() function returns zero on success, or eof if there is an error in\nclosing the file. this function actually flushes any data still pending in the buffer\nto the file, closes the file, and releases any memory used for the file. the eof is\na constant defined in the header file stdio.h.'
p374
aS'\nthere are various functions provided by c standard library to read and write a\nfile, character by character, or in the form of a fixed length string.'
p375
aS'\n\nwriting a file\nfollowing is the simplest function to write individual characters to a stream:\nint fputc( int c, file *fp );\nthe function fputc() writes the character value of the argument c to the output\nstream referenced by fp. it returns the written character written on success\notherwise eof if there is an error. you can use the following functions to write a\nnull-terminated string to a stream:\nint fputs( const char *s, file *fp );\nthe function fputs() writes the string s to the output stream referenced by fp. it\nreturns a non-negative value on success, otherwise eof is returned in case of\nany error. you can use int fprintf(file *fp,const char *format, ...) function\nas well to write a string into a file. try the following example.'
p376
aS'\nmake sure you have /tmp directory available. if it is not, then before\nproceeding, you must create this directory on your machine.'
p377
aS'\n\n#include <stdio.h>\n144\n\nc programming\n\nmain()\n{\nfile *fp;\n\nfp = fopen("/tmp/test.txt", "w+");\nfprintf(fp, "this is testing for fprintf...\\n");\nfputs("this is testing for fputs...\\n", fp);\nfclose(fp);\n}\nwhen the above code is compiled and executed, it creates a new file test.txt in\n/tmp directory and writes two lines using two different functions. let us read this\nfile in the next section.'
p378
aS'\n\nreading a file\ngiven below is the simplest function to read a single character from a file:\nint fgetc( file * fp );\nthe fgetc() function reads a character from the input file referenced by fp. the\nreturn value is the character read, or in case of any error, it returns eof. the\nfollowing function allows to read a string from a stream:\nchar *fgets( char *buf, int n, file *fp );\nthe functions fgets() reads up to n - 1 characters from the input stream\nreferenced by fp. it copies the read string into the buffer buf, appending\na null character to terminate the string.'
p379
aS"\nif this function encounters a newline character '\\n' or the end of the file eof\nbefore they have read the maximum number of characters, then it returns only\nthe characters read up to that point including the new line character. you can\nalso use int fscanf(file *fp, const char *format, ...) function to read strings\nfrom a file, but it stops reading after encountering the first space character."
p380
aS'\n#include <stdio.h>\n\nmain()\n{\nfile *fp;\nchar buff[255];\n145\n\nc programming\n\nfp = fopen("/tmp/test.txt", "r");\nfscanf(fp, "%s", buff);\nprintf("1 : %s\\n", buff );\n\nfgets(buff, 255, (file*)fp);\nprintf("2: %s\\n", buff );\n\nfgets(buff, 255, (file*)fp);\nprintf("3: %s\\n", buff );\nfclose(fp);\n\n}\nwhen the above code is compiled and executed, it reads the file created in the\nprevious section and produces the following result:\n1 : this\n2: is testing for fprintf...'
p381
aS'\n\n3: this is testing for fputs...'
p382
aS"\nlet's see a little more in detail about what happened here. first, fscanf() reads\njust this because after that, it encountered a space, second call is\nfor fgets() which reads the remaining line till it encountered end of line. finally,\nthe last call fgets() reads the second line completely."
p383
aS'\n\nbinary i/o functions\nthere are two functions that can be used for binary input and output:\nsize_t fread(void *ptr, size_t size_of_elements,\nsize_t number_of_elements, file *a_file);\n\nsize_t fwrite(const void *ptr, size_t size_of_elements,\nsize_t number_of_elements, file *a_file);\nboth of these functions should be used to read or write blocks of memories usually arrays or structures.'
p384
aS"\n\n146\n\nc programming\n\n23. preprocessors\n\nthe c preprocessor is not a part of the compiler, but is a separate step in the\ncompilation process. in simple terms, a c preprocessor is just a text substitution\ntool and it instructs the compiler to do required preprocessing before the actual\ncompilation. we'll refer to the c preprocessor as cpp."
p385
aS'\nall preprocessor commands begin with a hash symbol (#). it must be the first\nnonblank character, and for readability, a preprocessor directive should begin in\nthe first column. the following section lists down all the important preprocessor\ndirectives:\ndirective\n\ndescription\n\n#define\n\nsubstitutes a preprocessor macro.'
p386
aS'\n\n#include\n\ninserts a particular header from another file.'
p387
aS'\n\n#undef\n\nundefines a preprocessor macro.'
p388
aS'\n\n#ifdef\n\nreturns true if this macro is defined.'
p389
aS'\n\n#ifndef\n\nreturns true if this macro is not defined.'
p390
aS'\n\n#if\n\ntests if a compile time condition is true.'
p391
aS'\n\n#else\n\nthe alternative for #if.'
p392
aS'\n\n#elif\n\n#else and #if in one statement.'
p393
aS'\n\n#endif\n\nends preprocessor conditional.'
p394
aS'\n\n#error\n\nprints error message on stderr.'
p395
aS'\n\n#pragma\n\nissues special commands to the compiler, using a standardized\n147\n\nc programming\n\nmethod.'
p396
aS'\n\npreprocessors examples\nanalyze the following examples to understand various directives.'
p397
aS'\n#define max_array_length 20\nthis directive tells the cpp to replace instances of max_array_length with 20.'
p398
aS'\nuse #define for constants to increase readability.'
p399
aS'\n#include <stdio.h>\n#include "myheader.h"\nthese directives tell the cpp to get stdio.h from system libraries and add the\ntext to the current source file. the next line tells cpp to get myheader.h from\nthe local directory and add the content to the current source file.'
p400
aS'\n#undef\n\nfile_size\n\n#define file_size 42\nit tells the cpp to undefine existing file_size and define it as 42.'
p401
aS'\n#ifndef message\n#define message "you wish!"\n#endif\nit tells the cpp to define message only if message isn\'t already defined.'
p402
aS'\n#ifdef debug\n/* your debugging statements here */\n#endif\nit tells the cpp to process the statements enclosed if debug is defined. this is\nuseful if you pass the -ddebug flag to the gcc compiler at the time of\ncompilation. this will define debug, so you can turn debugging on and off onthe-fly during compilation.'
p403
aS'\n\npredefined macros\nansi c defines a number of macros. although each one is available for use in\nprogramming, the predefined macros should not be directly modified.'
p404
aS'\n\n148\n\nc programming\n\nmacro\n\ndescription\n\n__date__\n\nthe current date as a character literal in "mmm dd yyyy"\nformat.'
p405
aS'\n\n__time__\n\nthe current time as a character literal in "hh:mm:ss" format.'
p406
aS'\n\n__file__\n\nthis contains the current filename as a string literal.'
p407
aS'\n\n__line__\n\nthis contains the current line number as a decimal constant.'
p408
aS'\n\n__stdc__\n\ndefined as 1 when the compiler complies with the ansi\nstandard.'
p409
aS'\n\nlet\'s try the following example:\n#include <stdio.h>\n\nmain()\n{\nprintf("file :%s\\n", __file__ );\nprintf("date :%s\\n", __date__ );\nprintf("time :%s\\n", __time__ );\nprintf("line :%d\\n", __line__ );\nprintf("ansi :%d\\n", __stdc__ );\n\n}\nwhen the above code in a file test.c is compiled and executed, it produces the\nfollowing result:\nfile :test.c\ndate :jun 2 2012\ntime :03:36:24\nline :8\nansi :1\n149\n\nc programming\n\npreprocessor operators\nthe c preprocessor offers the following operators to help create macros:\n\nthe macro continuation (\\) operator\na macro is normally confined to a single line. the macro continuation operator\n(\\) is used to continue a macro that is too long for a single line. for example:\n#define\n\nmessage_for(a, b)\n\n\\\n\nprintf(#a " and " #b ": we love you!\\n")\n\nthe stringize (#) operator\nthe stringize or number-sign operator (#), when used within a macro definition,\nconverts a macro parameter into a string constant. this operator may be used\nonly in a macro having a specified argument or parameter list. for example:\n#include <stdio.h>\n\n#define\n\nmessage_for(a, b)\n\n\\\n\nprintf(#a " and " #b ": we love you!\\n")\n\nint main(void)\n{\nmessage_for(carole, debra);\nreturn 0;\n}\nwhen the above code is compiled and executed, it produces the following result:\ncarole and debra: we love you!\n\nthe token pasting (##) operator\nthe token-pasting operator (##) within a macro definition combines two\narguments. it permits two separate tokens in the macro definition to be joined\ninto a single token. for example:\n#include <stdio.h>\n\n150\n\nc programming\n\n#define tokenpaster(n) printf ("token" #n " = %d", token##n)\n\nint main(void)\n{\nint token34 = 40;\n\ntokenpaster(34);\nreturn 0;\n}\nwhen the above code is compiled and executed, it produces the following result:\ntoken34 = 40\nit happened so because this example results in the following actual output from\nthe preprocessor:\nprintf ("token34 = %d", token34);\nthis example shows the concatenation of token##n into token34 and here we\nhave used both stringize and token-pasting.'
p410
aS'\n\nthe defined() operator\nthe preprocessor defined operator is used in constant expressions to determine\nif an identifier is defined using #define. if the specified identifier is defined, the\nvalue is true (non-zero). if the symbol is not defined, the value is false (zero).'
p411
aS'\nthe defined operator is specified as follows:\n#include <stdio.h>\n\n#if !defined (message)\n#define message "you wish!"\n#endif\n\nint main(void)\n{\nprintf("here is the message: %s\\n", message);\nreturn 0;\n}\n151\n\nc programming\nwhen the above code is compiled and executed, it produces the following result:\nhere is the message: you wish!\n\nparameterized macros\none of the powerful functions of the cpp is the ability to simulate functions using\nparameterized macros. for example, we might have some code to square a\nnumber as follows:\nint square(int x) {\nreturn x * x;\n}\nwe can rewrite the above code using a macro as follows:\n#define square(x) ((x) * (x))\nmacros with arguments must be defined using the #define directive before they\ncan be used. the argument list is enclosed in parentheses and must immediately\nfollow the macro name. spaces are not allowed between the macro name and\nopen parenthesis. for example:\n#include <stdio.h>\n\n#define max(x,y) ((x) > (y) ? (x) : (y))\n\nint main(void)\n{\nprintf("max between 20 and 10 is %d\\n", max(10, 20));\nreturn 0;\n}\nwhen the above code is compiled and executed, it produces the following result:\nmax between 20 and 10 is 20\n\n152\n\n24. header files\n\nc programming\n\na header file is a file with extension .h which contains c function declarations\nand macro definitions to be shared between several source files. there are two\ntypes of header files: the files that the programmer writes and the files that\ncomes with your compiler.'
p412
aS'\nyou request to use a header file in your program by including it with the c\npreprocessing directive #include, like you have seen inclusion of stdio.h header\nfile, which comes along with your compiler.'
p413
aS'\nincluding a header file is equal to copying the content of the header file but we\ndo not do it because it will be error-prone and it is not a good idea to copy the\ncontent of a header file in the source files, especially if we have multiple source\nfiles in a program.'
p414
aS'\na simple practice in c or c++ programs is that we keep all the constants,\nmacros, system wide global variables, and function prototypes in the header files\nand include that header file wherever it is required.'
p415
aS'\n\ninclude syntax\nboth the user and the system header files are included using the preprocessing\ndirective #include. it has the following two forms:\n#include <file>\nthis form is used for system header files. it searches for a file named \xe2\x80\x98file\xe2\x80\x99 in a\nstandard list of system directories. you can prepend directories to this list with\nthe -i option while compiling your source code.'
p416
aS'\n#include "file"\nthis form is used for header files of your own program. it searches for a file\nnamed \xe2\x80\x98file\xe2\x80\x99 in the directory containing the current file. you can prepend\ndirectories to this list with the -i option while compiling your source code.'
p417
aS'\n\ninclude operation\nthe #include directive works by directing the c preprocessor to scan the\nspecified file as input before continuing with the rest of the current source file.'
p418
aS'\nthe output from the preprocessor contains the output already generated,\nfollowed by the output resulting from the included file, followed by the output\nthat comes from the text after the #include directive. for example, if you have\na header file header.h as follows:\n153\n\nc programming\n\nchar *test (void);\nand a main program called program.c that uses the header file, like this:\nint x;\n#include "header.h"\n\nint main (void)\n{\nputs (test ());\n}\nthe compiler will see the same token stream as it would if program.c read.'
p419
aS'\nint x;\nchar *test (void);\n\nint main (void)\n{\nputs (test ());\n}\n\nonce-only headers\nif a header file happens to be included twice, the compiler will process its\ncontents twice and it will result in an error. the standard way to prevent this is\nto enclose the entire real contents of the file in a conditional, like this:\n#ifndef header_file\n#define header_file\n\nthe entire header file file\n\n#endif\nthis construct is commonly known as a wrapper #ifndef. when the header is\nincluded again, the conditional will be false, because header_file is defined.'
p420
aS'\nthe preprocessor will skip over the entire contents of the file, and the compiler\nwill not see it twice.'
p421
aS'\n\n154\n\nc programming\n\ncomputed includes\nsometimes it is necessary to select one of the several different header files to be\nincluded into your program. for instance, they might specify configuration\nparameters to be used on different sorts of operating systems. you could do this\nwith a series of conditionals as follows:\n#if system_1\n# include "system_1.h"\n#elif system_2\n# include "system_2.h"\n#elif system_3\n...'
p422
aS'\n#endif\nbut as it grows, it becomes tedious, instead the preprocessor offers the ability to\nuse a macro for the header name. this is called a computed include. instead\nof writing a header name as the direct argument of #include, you simply put a\nmacro name there:\n#define system_h "system_1.h"\n...'
p423
aS'\n#include system_h\nsystem_h will be expanded, and the preprocessor will look for system_1.h as if\nthe #include had been written that way originally. system_h could be defined\nby your makefile with a -d option.'
p424
aS'\n\n155\n\n25. type casting\n\nc programming\n\ntype casting is a way to convert a variable from one data type to another data\ntype. for example, if you want to store a \xe2\x80\x98long\xe2\x80\x99 value into a simple integer, then\nyou can type cast \xe2\x80\x98long\xe2\x80\x99 to \xe2\x80\x98int\xe2\x80\x99. you can convert the values from one type to\nanother explicitly using the cast operator as follows:\n(type_name) expression\nconsider the following example where the cast operator causes the division of\none integer variable by another to be performed as a floating-point operation:\n#include <stdio.h>\n\nmain()\n{\nint sum = 17, count = 5;\ndouble mean;\n\nmean = (double) sum / count;\nprintf("value of mean : %f\\n", mean );\n\n}\nwhen the above code is compiled and executed, it produces the following result:\nvalue of mean : 3.400000\nit should be noted here that the cast operator has precedence over division, so\nthe value of sum is first converted to type double and finally it gets divided by\ncount yielding a double value.'
p425
aS'\ntype conversions can be implicit which is performed by the compiler\nautomatically, or it can be specified explicitly through the use of the cast\noperator. it is considered good programming practice to use the cast operator\nwhenever type conversions are necessary.'
p426
aS'\n\n156\n\nc programming\n\ninteger promotion\ninteger promotion is the process by which values of integer type "smaller"\nthan int or unsigned int are converted either to int or unsigned int. consider\nan example of adding a character with an integer:\n#include <stdio.h>\n\nmain()\n{\nint\n\ni = 17;\n\nchar c = \'c\'; /* ascii value is 99 */\nint sum;\n\nsum = i + c;\nprintf("value of sum : %d\\n", sum );\n\n}\nwhen the above code is compiled and executed, it produces the following result:\nvalue of sum : 116\nhere, the value of sum is 116 because the compiler is doing integer promotion\nand converting the value of \'c\' to ascii before performing the actual addition\noperation.'
p427
aS'\n\nusual arithmetic conversion\nthe usual arithmetic conversions are implicitly performed to cast their values\nto a common type. the compiler first performs integer promotion; if the\noperands still have different types, then they are converted to the type that\nappears highest in the following hierarchy:\n\n157\n\nc programming\n\nthe usual arithmetic conversions are not performed for the assignment\noperators, nor for the logical operators && and ||. let us take the following\nexample to understand the concept:\n#include <stdio.h>\n\nmain()\n{\nint\n\ni = 17;\n\nchar c = \'c\'; /* ascii value is 99 */\nfloat sum;\n\nsum = i + c;\nprintf("value of sum : %f\\n", sum );\n\n}\n\n158\n\nc programming\nwhen the above code is compiled and executed, it produces the following result:\nvalue of sum : 116.000000\nhere, it is simple to understand that first c gets converted to integer, but as the\nfinal value is double, usual arithmetic conversion applies and the compiler\nconverts i and c into \xe2\x80\x98float\xe2\x80\x99 and adds them yielding a \xe2\x80\x98float\xe2\x80\x99 result.'
p428
aS'\n\n159\n\nc programming\n\n26. error handling\n\nas such, c programming does not provide direct support for error handling but\nbeing a sytem programming language, it provides you access at lower level in\nthe form of return values. most of the c or even unix function calls return -1 or\nnull in case of any error and set an error code errno. it is set as a global\nvariable and indicates an error occurred during any function call. you can find\nvarious error codes defined in <error.h> header file.'
p429
aS'\nso a c programmer can check the returned values and can take appropriate\naction depending on the return value. it is a good practice to set errno to 0 at\nthe time of initializing a program. a value of 0 indicates that there is no error in\nthe program.'
p430
aS'\n\nerrno, perror(), and strerror()\nthe c programming language provides perror() and strerror() functions which\ncan be used to display the text message associated with errno.'
p431
aS'\n\xef\x82\xb7\n\nthe perror() function displays the string you pass to it, followed by a\ncolon, a space, and then the textual representation of the current errno\nvalue.'
p432
aS'\n\n\xef\x82\xb7\n\nthe strerror() function, which returns\nrepresentation of the current errno value.'
p433
aS"\n\na\n\npointer\n\nto\n\nthe\n\ntextual\n\nlet's try to simulate an error condition and try to open a file which does not\nexist. here i'm using both the functions to show the usage, but you can use one\nor more ways of printing your errors. second important point to note is that you\nshould use stderr file stream to output all the errors."
p434
aS'\n#include <stdio.h>\n#include <errno.h>\n#include <string.h>\n\nextern int errno ;\n\nint main ()\n{\nfile * pf;\nint errnum;\n\n160\n\nc programming\n\npf = fopen ("unexist.txt", "rb");\nif (pf == null)\n{\nerrnum = errno;\nfprintf(stderr, "value of errno: %d\\n", errno);\nperror("error printed by perror");\nfprintf(stderr, "error opening file: %s\\n", strerror( errnum ));\n}\nelse\n{\nfclose (pf);\n}\nreturn 0;\n}\nwhen the above code is compiled and executed, it produces the following result:\nvalue of errno: 2\nerror printed by perror: no such file or directory\nerror opening file: no such file or directory\n\ndivide by zero errors\nit is a common problem that at the time of dividing any number, programmers\ndo not check if a divisor is zero and finally it creates a runtime error.'
p435
aS'\nthe code below fixes this by checking if the divisor is zero before dividing:\n#include <stdio.h>\n#include <stdlib.h>\n\nmain()\n{\nint dividend = 20;\nint divisor = 0;\nint quotient;\n\nif( divisor == 0){\n161\n\nc programming\n\nfprintf(stderr, "division by zero! exiting...\\n");\nexit(-1);\n}\nquotient = dividend / divisor;\nfprintf(stderr, "value of quotient : %d\\n", quotient );\n\nexit(0);\n}\nwhen the above code is compiled and executed, it produces the following result:\ndivision by zero! exiting...'
p436
aS'\n\nprogram exit status\nit is a common practice to exit with a value of exit_success in case of\nprogram coming out after a successful operation. here, exit_success is a\nmacro and it is defined as 0.'
p437
aS'\nif you have an error condition in your program and you are coming out then you\nshould exit with a status exit_failure which is defined as -1. so let\'s write\nabove program as follows:\n#include <stdio.h>\n#include <stdlib.h>\n\nmain()\n{\nint dividend = 20;\nint divisor = 5;\nint quotient;\n\nif( divisor == 0){\nfprintf(stderr, "division by zero! exiting...\\n");\nexit(exit_failure);\n}\nquotient = dividend / divisor;\nfprintf(stderr, "value of quotient : %d\\n", quotient );\n\n162\n\nc programming\n\nexit(exit_success);\n}\nwhen the above code is compiled and executed, it produces the following result:\nvalue of quotient : 4\n\n163\n\n27. recursion\n\nc programming\n\nrecursion is the process of repeating items in a self-similar way. in\nprogramming languages, if a program allows you to call a function inside the\nsame function, then it is called a recursive call of the function.'
p438
aS'\nvoid recursion()\n{\nrecursion();\n\n/* function calls itself */\n\n}\n\nint main()\n{\nrecursion();\n}\nthe c programming language supports recursion, i.e., a function to call itself.'
p439
aS'\nbut while using recursion, programmers need to be careful to define an exit\ncondition from the function, otherwise it will go into an infinite loop.'
p440
aS'\nrecursive functions are very useful to solve many mathematical problems, such\nas calculating the factorial of a number, generating fibonacci series, etc.'
p441
aS'\n\nnumber factorial\nthe following example calculates the factorial of a given number using a\nrecursive function:\n#include <stdio.h>\n\nint factorial(unsigned int i)\n{\nif(i <= 1)\n{\nreturn 1;\n}\nreturn i * factorial(i - 1);\n164\n\nc programming\n\n}\nint\n\nmain()\n\n{\nint i = 15;\nprintf("factorial of %d is %d\\n", i, factorial(i));\nreturn 0;\n}\nwhen the above code is compiled and executed, it produces the following result:\nfactorial of 15 is 2004310016\n\nfibonacci series\nthe following example generates the fibonacci series for a given number using a\nrecursive function:\n#include <stdio.h>\n\nint fibonaci(int i)\n{\nif(i == 0)\n{\nreturn 0;\n}\nif(i == 1)\n{\nreturn 1;\n}\nreturn fibonaci(i-1) + fibonaci(i-2);\n}\n\nint\n\nmain()\n\n{\nint i;\nfor (i = 0; i < 10; i++)\n{\n165\n\nc programming\n\nprintf("%d\\t%n", fibonaci(i));\n}\nreturn 0;\n}\nwhen the above code is compiled and executed, it produces the following result:\n0\n\n1\n\n1\n\n2\n\n3\n\n5\n\n8\n\n13\n\n21\n\n34\n\n166\n\nc programming\n\n28. variable arguments\n\nsometimes, you may come across a situation, when you want to have a\nfunction, which can take variable number of arguments, i.e., parameters,\ninstead of predefined number of parameters. the c programming language\nprovides a solution for this situation and you are allowed to define a function\nwhich can accept variable number of parameters based on your requirement.'
p442
aS'\nthe following example shows the definition of such a function.'
p443
aS'\nint func(int, ... )\n{\n.\n.\n.\n}\n\nint main()\n{\nfunc(1, 2, 3);\nfunc(1, 2, 3, 4);\n}\nit should be noted that the function func() has its last argument as ellipses,\ni.e., three dotes (...) and the one just before the ellipses is always an int which\nwill represent the total number variable arguments passed. to use such\nfunctionality, you need to make use of stdarg.h header file which provides the\nfunctions and macros to implement the functionality of variable arguments and\nfollow the given steps:\n1. define a function with its last parameter as ellipses and the one just\nbefore the ellipses is always an int which will represent the number of\narguments.'
p444
aS'\n2. create a va_list type variable in the function definition. this type is\ndefined in stdarg.h header file.'
p445
aS'\n3. use int parameter and va_start macro to initialize the va_list variable to\nan argument list. the macro va_start is defined in stdarg.h header file.'
p446
aS'\n4. use va_arg macro and va_list variable to access each item in argument\nlist.'
p447
aS'\n167\n\nc programming\n5. use\na\nmacro va_end to\nto va_list variable.'
p448
aS'\n\nclean\n\nup\n\nthe\n\nmemory\n\nassigned\n\nnow let us follow the above steps and write down a simple function which can\ntake the variable number of parameters and return their average:\n#include <stdio.h>\n#include <stdarg.h>\n\ndouble average(int num,...)\n{\n\nva_list valist;\ndouble sum = 0.0;\nint i;\n\n/* initialize valist for num number of arguments */\nva_start(valist, num);\n\n/* access all the arguments assigned to valist */\nfor (i = 0; i < num; i++)\n{\nsum += va_arg(valist, int);\n}\n/* clean memory reserved for valist */\nva_end(valist);\n\nreturn sum/num;\n}\n\nint main()\n{\nprintf("average of 2, 3, 4, 5 = %f\\n", average(4, 2,3,4,5));\nprintf("average of 5, 10, 15 = %f\\n", average(3, 5,10,15));\n}\n\n168\n\nc programming\nwhen the above code is compiled and executed, it produces the following result.'
p449
aS'\nit should be noted that the function average() has been called twice and each\ntime the first argument represents the total number of variable arguments being\npassed. only ellipses will be used to pass variable number of arguments.'
p450
aS'\naverage of 2, 3, 4, 5 = 3.500000\naverage of 5, 10, 15 = 10.000000\n\n169\n\nc programming\n\n29. memory management\n\nthis chapter explains dynamic memory management in c. the c programming\nlanguage provides several functions for memory allocation and management.'
p451
aS'\nthese functions can be found in the <stdlib.h> header file.'
p452
aS'\n\ns.n.'
p453
aS'\n\nfunction and description\n\n1\n\nvoid *calloc(int num, int size);\nthis function allocates an array of num elements each of which size in\nbytes will be size.'
p454
aS'\n\n2\n\nvoid free(void *address);\nthis function releases a block of memory block specified by address.'
p455
aS'\n\n3\n\nvoid *malloc(int num);\nthis function allocates an array of num bytes and leave them initialized.'
p456
aS'\n\n4\n\nvoid *realloc(void *address, int newsize);\nthis function re-allocates memory extending it upto newsize.'
p457
aS'\n\nallocating memory dynamically\nwhile programming, if you are aware of the size of an array, then it is easy and\nyou can define it as an array. for example, to store a name of any person, it can\ngo up to a maximum of 100 characters, so you can define something as follows:\nchar name[100];\nbut now let us consider a situation where you have no idea about the length of\nthe text you need to store, for example, you want to store a detailed description\nabout a topic. here we need to define a pointer to character without defining\nhow much memory is required and later, based on requirement, we can allocate\nmemory as shown in the below example:\n#include <stdio.h>\n170\n\nc programming\n\n#include <stdlib.h>\n#include <string.h>\n\nint main()\n{\nchar name[100];\nchar *description;\n\nstrcpy(name, "zara ali");\n\n/* allocate memory dynamically */\ndescription = malloc( 200 * sizeof(char) );\nif( description == null )\n{\nfprintf(stderr, "error - unable to allocate required memory\\n");\n}\nelse\n{\nstrcpy( description, "zara ali a dps student in class 10th");\n}\nprintf("name = %s\\n", name );\nprintf("description: %s\\n", description );\n}\nwhen the above code is compiled and executed, it produces the following result.'
p458
aS'\nname = zara ali\ndescription: zara ali a dps student in class 10th\nsame program can be written using calloc(); only thing is you need to replace\nmalloc with calloc as follows:\ncalloc(200, sizeof(char));\nso you have complete control and you can pass any size value while allocating\nmemory, unlike arrays where once the size is defined, you cannot change it.'
p459
aS'\n\n171\n\nc programming\n\nresizing and releasing memory\nwhen your program comes out, operating system automatically release all the\nmemory allocated by your program but as a good practice when you are not in\nneed of memory anymore then you should release that memory by calling the\nfunction free().'
p460
aS'\nalternatively, you can increase or decrease the size of an allocated memory\nblock by calling the function realloc(). let us check the above program once\nagain and make use of realloc() and free() functions:\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main()\n{\nchar name[100];\nchar *description;\n\nstrcpy(name, "zara ali");\n\n/* allocate memory dynamically */\ndescription = malloc( 30 * sizeof(char) );\nif( description == null )\n{\nfprintf(stderr, "error - unable to allocate required memory\\n");\n}\nelse\n{\nstrcpy( description, "zara ali a dps student.");\n}\n/* suppose you want to store bigger description */\ndescription = realloc( description, 100 * sizeof(char) );\nif( description == null )\n{\nfprintf(stderr, "error - unable to allocate required memory\\n");\n}\n172\n\nc programming\n\nelse\n{\nstrcat( description, "she is in class 10th");\n}\n\nprintf("name = %s\\n", name );\nprintf("description: %s\\n", description );\n\n/* release memory using free() function */\nfree(description);\n}\nwhen the above code is compiled and executed, it produces the following result.'
p461
aS'\nname = zara ali\ndescription: zara ali a dps student.she is in class 10th\nyou can try the above example without re-allocating extra memory, and strcat()\nfunction will give an error due to lack of available memory in description.'
p462
aS'\n\n173\n\nc programming\n\n30. command line arguments\nit is possible to pass some values from the command line to your c programs\nwhen they are executed. these values are called command line\narguments and many times they are important for your program especially\nwhen you want to control your program from outside instead of hard coding\nthose values inside the code.'
p463
aS'\nthe command line arguments are handled using main() function arguments\nwhere argc refers to the number of arguments passed, and argv[] is a pointer\narray which points to each argument passed to the program. following is a\nsimple example which checks if there is any argument supplied from the\ncommand line and take action accordingly:\n#include <stdio.h>\n\nint main( int argc, char *argv[] )\n{\nif( argc == 2 )\n{\nprintf("the argument supplied is %s\\n", argv[1]);\n}\nelse if( argc > 2 )\n{\nprintf("too many arguments supplied.\\n");\n}\nelse\n{\nprintf("one argument expected.\\n");\n}\n}\nwhen the above code is compiled and executed with a single argument, it\nproduces the following result.'
p464
aS'\n$./a.out testing\nthe argument supplied is testing\n174\n\nc programming\nwhen the above code is compiled and executed with two arguments, it produces\nthe following result.'
p465
aS'\n$./a.out testing1 testing2\ntoo many arguments supplied.'
p466
aS'\nwhen the above code is compiled and executed without passing any argument,\nit produces the following result.'
p467
aS'\n$./a.out\none argument expected\nit should be noted that argv[0] holds the name of the program itself\nand argv[1] is a pointer to the first command line argument supplied, and\n*argv[n] is the last argument. if no arguments are supplied, argc will be one,\nand if you pass one argument, then argc is set at 2.'
p468
aS'\nyou pass all the command line arguments separated by a space, but if argument\nitself has a space then you can pass such arguments by putting them inside\ndouble quotes "" or single quotes \'\'. let us re-write above example once again\nwhere we will print program name and we also pass a command line argument\nby putting inside double quotes:\n#include <stdio.h>\n\nint main( int argc, char *argv[] )\n{\nprintf("program name %s\\n", argv[0]);\n\nif( argc == 2 )\n{\nprintf("the argument supplied is %s\\n", argv[1]);\n}\nelse if( argc > 2 )\n{\nprintf("too many arguments supplied.\\n");\n}\nelse\n{\nprintf("one argument expected.\\n");\n}\n175\n\nc programming\n\n}\nwhen the above code is compiled and executed with a single argument\nseparated by space but inside double quotes, it produces the following result.'
p469
a.